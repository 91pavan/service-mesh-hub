// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/supergloo/api/v1/encryption.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EncryptionRule struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by supergloo during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata,proto3" json:"metadata"`
	// target where we apply this rule. this can be a mesh group or an individual mesh
	TargetMesh *core.ResourceRef `protobuf:"bytes,1,opt,name=target_mesh,json=targetMesh,proto3" json:"target_mesh,omitempty"`
	// contains the configuration that will be applied to the target mesh
	Spec                 *EncryptionRuleSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EncryptionRule) Reset()         { *m = EncryptionRule{} }
func (m *EncryptionRule) String() string { return proto.CompactTextString(m) }
func (*EncryptionRule) ProtoMessage()    {}
func (*EncryptionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_d994fe23dca3ff88, []int{0}
}
func (m *EncryptionRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptionRule.Unmarshal(m, b)
}
func (m *EncryptionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptionRule.Marshal(b, m, deterministic)
}
func (m *EncryptionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptionRule.Merge(m, src)
}
func (m *EncryptionRule) XXX_Size() int {
	return xxx_messageInfo_EncryptionRule.Size(m)
}
func (m *EncryptionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptionRule.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptionRule proto.InternalMessageInfo

func (m *EncryptionRule) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *EncryptionRule) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *EncryptionRule) GetTargetMesh() *core.ResourceRef {
	if m != nil {
		return m.TargetMesh
	}
	return nil
}

func (m *EncryptionRule) GetSpec() *EncryptionRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// the encryption configuration that will be applied by the role
type EncryptionRuleSpec struct {
	// whether or not mutual TLS will be enabled between pods
	MtlsEnabled bool `protobuf:"varint,1,opt,name=mtls_enabled,json=mtlsEnabled,proto3" json:"mtls_enabled,omitempty"`
	// if set, rootCertificate will override the root certificate used by the mesh
	// to encrypt mtls connections.
	//
	// The structure of the secret must be a standard kubernetes TLS secret
	// such as can be created via `kubectl create secret tls`
	//
	// if mtlsEnabled is false, this field is ignored
	// If deploying to Consul, Consul Connect requires that the cert and key are generated using ec, not rsa.
	RootCertificate      *core.ResourceRef `protobuf:"bytes,2,opt,name=root_certificate,json=rootCertificate,proto3" json:"root_certificate,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EncryptionRuleSpec) Reset()         { *m = EncryptionRuleSpec{} }
func (m *EncryptionRuleSpec) String() string { return proto.CompactTextString(m) }
func (*EncryptionRuleSpec) ProtoMessage()    {}
func (*EncryptionRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d994fe23dca3ff88, []int{1}
}
func (m *EncryptionRuleSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptionRuleSpec.Unmarshal(m, b)
}
func (m *EncryptionRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptionRuleSpec.Marshal(b, m, deterministic)
}
func (m *EncryptionRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptionRuleSpec.Merge(m, src)
}
func (m *EncryptionRuleSpec) XXX_Size() int {
	return xxx_messageInfo_EncryptionRuleSpec.Size(m)
}
func (m *EncryptionRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptionRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptionRuleSpec proto.InternalMessageInfo

func (m *EncryptionRuleSpec) GetMtlsEnabled() bool {
	if m != nil {
		return m.MtlsEnabled
	}
	return false
}

func (m *EncryptionRuleSpec) GetRootCertificate() *core.ResourceRef {
	if m != nil {
		return m.RootCertificate
	}
	return nil
}

func init() {
	proto.RegisterType((*EncryptionRule)(nil), "supergloo.solo.io.EncryptionRule")
	proto.RegisterType((*EncryptionRuleSpec)(nil), "supergloo.solo.io.EncryptionRuleSpec")
}

func init() {
	proto.RegisterFile("github.com/solo-io/supergloo/api/v1/encryption.proto", fileDescriptor_d994fe23dca3ff88)
}

var fileDescriptor_d994fe23dca3ff88 = []byte{
	// 403 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x6e, 0xd3, 0x40,
	0x14, 0xc6, 0x49, 0x64, 0x55, 0xd5, 0x04, 0x95, 0x32, 0xaa, 0x90, 0xa9, 0x50, 0x81, 0x4a, 0x08,
	0x16, 0x74, 0x46, 0x2d, 0x2c, 0xa0, 0xcb, 0x42, 0x97, 0xdd, 0x38, 0x3b, 0x36, 0xd1, 0x78, 0xfc,
	0x3c, 0x19, 0xc5, 0xce, 0x1b, 0xcd, 0x1f, 0x10, 0x0b, 0x36, 0xb9, 0x02, 0x97, 0xe0, 0x28, 0x9c,
	0x82, 0x05, 0x37, 0xc8, 0x0d, 0x90, 0xc7, 0x76, 0xa2, 0x28, 0x28, 0x4a, 0x57, 0xf6, 0xbc, 0xef,
	0xfb, 0xd9, 0xdf, 0x7b, 0x6f, 0xc8, 0x7b, 0xa5, 0xfd, 0x34, 0xe4, 0x4c, 0x62, 0xcd, 0x1d, 0x56,
	0x78, 0xa1, 0x91, 0xbb, 0x60, 0xc0, 0xaa, 0x0a, 0x91, 0x0b, 0xa3, 0xf9, 0xd7, 0x4b, 0x0e, 0x73,
	0x69, 0xbf, 0x1b, 0xaf, 0x71, 0xce, 0x8c, 0x45, 0x8f, 0xf4, 0xf1, 0xca, 0xc2, 0x1a, 0x88, 0x69,
	0x3c, 0x3d, 0x51, 0xa8, 0x30, 0xaa, 0xbc, 0x79, 0x6b, 0x8d, 0xa7, 0x67, 0x0a, 0x51, 0x55, 0xc0,
	0xe3, 0x29, 0x0f, 0x25, 0x2f, 0x82, 0x15, 0xeb, 0x0f, 0x6d, 0xeb, 0xdf, 0xac, 0x30, 0x06, 0xac,
	0xeb, 0xf4, 0xcb, 0xff, 0xc5, 0x6b, 0x9e, 0x33, 0xed, 0xfb, 0x74, 0x35, 0x78, 0x51, 0x08, 0x2f,
	0x3a, 0x84, 0xef, 0x81, 0x38, 0x2f, 0x7c, 0xe8, 0xff, 0xf1, 0x76, 0x0f, 0xc0, 0x42, 0x79, 0x8f,
	0x44, 0xfd, 0xb9, 0x45, 0xce, 0x7f, 0x0e, 0xc9, 0xd1, 0xed, 0x6a, 0x84, 0x59, 0xa8, 0x80, 0x5e,
	0x91, 0x83, 0x36, 0x43, 0x5a, 0xbc, 0x18, 0xbc, 0x19, 0x5d, 0x9d, 0x30, 0x89, 0x16, 0xfa, 0x61,
	0xb2, 0x71, 0xd4, 0x6e, 0x92, 0xdf, 0x7f, 0x9e, 0x3f, 0xc8, 0x3a, 0x27, 0xfd, 0x40, 0x0e, 0xfb,
	0x56, 0x53, 0x88, 0xd4, 0x93, 0x4d, 0xea, 0xae, 0x53, 0x3b, 0x6e, 0xe5, 0xa6, 0xd7, 0x64, 0xe4,
	0x85, 0x55, 0xe0, 0x27, 0x35, 0xb8, 0x69, 0x3a, 0x88, 0xf0, 0xd3, 0x4d, 0x38, 0x03, 0x87, 0xc1,
	0x4a, 0xc8, 0xa0, 0xcc, 0x48, 0xeb, 0xbe, 0x03, 0x37, 0xa5, 0x1f, 0x49, 0xe2, 0x0c, 0xc8, 0x74,
	0x18, 0xa1, 0x57, 0x6c, 0x6b, 0xf3, 0x6c, 0xb3, 0xb5, 0xb1, 0x01, 0x99, 0x45, 0xe4, 0xfa, 0xd9,
	0x62, 0x99, 0x24, 0x64, 0x08, 0x76, 0xb1, 0x4c, 0x8e, 0xe9, 0x11, 0xf4, 0x36, 0x1b, 0x2a, 0x70,
	0xe7, 0x3f, 0x08, 0xdd, 0x26, 0xe9, 0x4b, 0xf2, 0xb0, 0xf6, 0x95, 0x9b, 0xc0, 0x5c, 0xe4, 0x15,
	0x14, 0x31, 0xeb, 0x61, 0x36, 0x6a, 0x6a, 0xb7, 0x6d, 0x89, 0x7e, 0x26, 0xc7, 0x16, 0xd1, 0x4f,
	0x24, 0x58, 0xaf, 0x4b, 0x2d, 0x85, 0x87, 0x2e, 0xdd, 0x8e, 0x96, 0x1e, 0x35, 0xc8, 0xa7, 0x35,
	0x71, 0x73, 0xf1, 0xeb, 0xef, 0xd9, 0xe0, 0xcb, 0xeb, 0x9d, 0xd7, 0xdf, 0xcc, 0x54, 0xb7, 0xd2,
	0xfc, 0x20, 0xae, 0xf2, 0xdd, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xae, 0x89, 0xa1, 0x40, 0x30,
	0x03, 0x00, 0x00,
}

func (this *EncryptionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncryptionRule)
	if !ok {
		that2, ok := that.(EncryptionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if !this.TargetMesh.Equal(that1.TargetMesh) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *EncryptionRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncryptionRuleSpec)
	if !ok {
		that2, ok := that.(EncryptionRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MtlsEnabled != that1.MtlsEnabled {
		return false
	}
	if !this.RootCertificate.Equal(that1.RootCertificate) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
