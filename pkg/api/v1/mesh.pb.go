// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mesh.proto

/*
Package v1 is a generated protocol buffer package.

It is generated from these files:
	mesh.proto

It has these top-level messages:
	Mesh
	MeshMetadata
	Encryption
	Ingress
	IngressHost
	Path
	Destination
	Route
	RoutePlugin
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import core_solo_io "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
import core_solo_io1 "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TODO: Eventually we want to plug in new meshes easier, but for now it's useful to enumerate in the config
type MeshType int32

const (
	MeshType_ISTIO    MeshType = 0
	MeshType_LINKERD1 MeshType = 1
)

var MeshType_name = map[int32]string{
	0: "ISTIO",
	1: "LINKERD1",
}
var MeshType_value = map[string]int32{
	"ISTIO":    0,
	"LINKERD1": 1,
}

func (x MeshType) String() string {
	return proto.EnumName(MeshType_name, int32(x))
}
func (MeshType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesh, []int{0} }

//
// @solo-kit:resource.short_name=mesh
// @solo-kit:resource.plural_name=meshes
// @solo-kit:resource.resource_groups=translator.supergloo.solo.io
//
//
// // Initial API thoughts based on potential user workflows: https://github.com/solo-io/supergloo/wiki/User-Workflows
// // Notes on what Itsio and Linkerd1 support on wiki: https://github.com/solo-io/supergloo/wiki
//
// // Any user-configurable settings for a service mesh
// // This isn't meant to cover install or initial configuration of the mesh
// // The supergloo server would apply CRUD on MeshConfigs
type Mesh struct {
	MeshMetadata *MeshMetadata `protobuf:"bytes,1,opt,name=mesh_metadata,json=meshMetadata" json:"mesh_metadata,omitempty"`
	Encryption   *Encryption   `protobuf:"bytes,2,opt,name=encryption" json:"encryption,omitempty"`
	Ingress      *Ingress      `protobuf:"bytes,3,opt,name=ingress" json:"ingress,omitempty"`
	Routes       []*Route      `protobuf:"bytes,4,rep,name=routes" json:"routes,omitempty"`
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core_solo_io1.Status `protobuf:"bytes,6,opt,name=status" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata core_solo_io.Metadata `protobuf:"bytes,7,opt,name=metadata" json:"metadata"`
}

func (m *Mesh) Reset()                    { *m = Mesh{} }
func (m *Mesh) String() string            { return proto.CompactTextString(m) }
func (*Mesh) ProtoMessage()               {}
func (*Mesh) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{0} }

func (m *Mesh) GetMeshMetadata() *MeshMetadata {
	if m != nil {
		return m.MeshMetadata
	}
	return nil
}

func (m *Mesh) GetEncryption() *Encryption {
	if m != nil {
		return m.Encryption
	}
	return nil
}

func (m *Mesh) GetIngress() *Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *Mesh) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *Mesh) GetStatus() core_solo_io1.Status {
	if m != nil {
		return m.Status
	}
	return core_solo_io1.Status{}
}

func (m *Mesh) GetMetadata() core_solo_io.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core_solo_io.Metadata{}
}

type MeshMetadata struct {
	Name     string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MeshType MeshType `protobuf:"varint,2,opt,name=meshType,proto3,enum=supergloo.solo.io.MeshType" json:"meshType,omitempty"`
}

func (m *MeshMetadata) Reset()                    { *m = MeshMetadata{} }
func (m *MeshMetadata) String() string            { return proto.CompactTextString(m) }
func (*MeshMetadata) ProtoMessage()               {}
func (*MeshMetadata) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{1} }

func (m *MeshMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MeshMetadata) GetMeshType() MeshType {
	if m != nil {
		return m.MeshType
	}
	return MeshType_ISTIO
}

// Defines mesh-level configuration for encryption. Supports communication within a mesh and through ingress.
// Communicating between TLS and non-TLS enabled services is not supported. TODO: Is this ok?
// TODO: What do we need to support communication across mesh?
type Encryption struct {
	// If set to true, TLS is enabled across the entire mesh.
	TlsEnabled bool `protobuf:"varint,1,opt,name=tlsEnabled,proto3" json:"tlsEnabled,omitempty"`
	// If TLS is enabled, this is the name of the secret containing the certs.
	// When using Istio, this should either be "istio.default", meaning Istio is using the default Citadel cert
	// generation, or "cacert", which is a custom-uploaded Kubernetes secret containing all the cert files.
	// When using Linkerd, this is the name of a secret that will be mounted into the linkerd Kubernetes DaemonSet.
	CertSecret string `protobuf:"bytes,2,opt,name=certSecret,proto3" json:"certSecret,omitempty"`
}

func (m *Encryption) Reset()                    { *m = Encryption{} }
func (m *Encryption) String() string            { return proto.CompactTextString(m) }
func (*Encryption) ProtoMessage()               {}
func (*Encryption) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{2} }

func (m *Encryption) GetTlsEnabled() bool {
	if m != nil {
		return m.TlsEnabled
	}
	return false
}

func (m *Encryption) GetCertSecret() string {
	if m != nil {
		return m.CertSecret
	}
	return ""
}

// Defines Ingress for the service mesh. The Ingress port is 80 for HTTP with no TLS, and 443 for HTTP with TLS.
type Ingress struct {
	// The name of the gateway. In Istio, a Gateway is configured with this name, and a VirtualService references
	// this gateway name. In Linkerd1, an Ingress is configured with this name.
	Name string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Host []*IngressHost `protobuf:"bytes,2,rep,name=host" json:"host,omitempty"`
}

func (m *Ingress) Reset()                    { *m = Ingress{} }
func (m *Ingress) String() string            { return proto.CompactTextString(m) }
func (*Ingress) ProtoMessage()               {}
func (*Ingress) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{3} }

func (m *Ingress) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ingress) GetHost() []*IngressHost {
	if m != nil {
		return m.Host
	}
	return nil
}

type IngressHost struct {
	Host  string  `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Paths []*Path `protobuf:"bytes,2,rep,name=paths" json:"paths,omitempty"`
}

func (m *IngressHost) Reset()                    { *m = IngressHost{} }
func (m *IngressHost) String() string            { return proto.CompactTextString(m) }
func (*IngressHost) ProtoMessage()               {}
func (*IngressHost) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{4} }

func (m *IngressHost) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *IngressHost) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

type Path struct {
	PathPrefix  string       `protobuf:"bytes,1,opt,name=pathPrefix,proto3" json:"pathPrefix,omitempty"`
	Destination *Destination `protobuf:"bytes,2,opt,name=destination" json:"destination,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{5} }

func (m *Path) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *Path) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

type Destination struct {
	// In Itsio, this is the name of the Kubernetes VirtualService. In Linkerd1, this is the name of the Kubernetes Service.
	Name   string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Port   int32             `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (m *Destination) String() string            { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{6} }

func (m *Destination) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Destination) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Destination) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// TODO: Do we require users to enumerate all mesh routes in the config? Or just the routes necessary for supergloo workflows?
type Route struct {
	Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Host         string         `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	PathPrefix   string         `protobuf:"bytes,3,opt,name=pathPrefix,proto3" json:"pathPrefix,omitempty"`
	Rewrite      string         `protobuf:"bytes,4,opt,name=rewrite,proto3" json:"rewrite,omitempty"`
	Destination  *Destination   `protobuf:"bytes,5,opt,name=destination" json:"destination,omitempty"`
	RoutePlugins []*RoutePlugin `protobuf:"bytes,6,rep,name=routePlugins" json:"routePlugins,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{7} }

func (m *Route) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Route) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Route) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *Route) GetRewrite() string {
	if m != nil {
		return m.Rewrite
	}
	return ""
}

func (m *Route) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *Route) GetRoutePlugins() []*RoutePlugin {
	if m != nil {
		return m.RoutePlugins
	}
	return nil
}

type RoutePlugin struct {
}

func (m *RoutePlugin) Reset()                    { *m = RoutePlugin{} }
func (m *RoutePlugin) String() string            { return proto.CompactTextString(m) }
func (*RoutePlugin) ProtoMessage()               {}
func (*RoutePlugin) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{8} }

func init() {
	proto.RegisterType((*Mesh)(nil), "supergloo.solo.io.Mesh")
	proto.RegisterType((*MeshMetadata)(nil), "supergloo.solo.io.MeshMetadata")
	proto.RegisterType((*Encryption)(nil), "supergloo.solo.io.Encryption")
	proto.RegisterType((*Ingress)(nil), "supergloo.solo.io.Ingress")
	proto.RegisterType((*IngressHost)(nil), "supergloo.solo.io.IngressHost")
	proto.RegisterType((*Path)(nil), "supergloo.solo.io.Path")
	proto.RegisterType((*Destination)(nil), "supergloo.solo.io.Destination")
	proto.RegisterType((*Route)(nil), "supergloo.solo.io.Route")
	proto.RegisterType((*RoutePlugin)(nil), "supergloo.solo.io.RoutePlugin")
	proto.RegisterEnum("supergloo.solo.io.MeshType", MeshType_name, MeshType_value)
}
func (this *Mesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Mesh)
	if !ok {
		that2, ok := that.(Mesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MeshMetadata.Equal(that1.MeshMetadata) {
		return false
	}
	if !this.Encryption.Equal(that1.Encryption) {
		return false
	}
	if !this.Ingress.Equal(that1.Ingress) {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	return true
}
func (this *MeshMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeshMetadata)
	if !ok {
		that2, ok := that.(MeshMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.MeshType != that1.MeshType {
		return false
	}
	return true
}
func (this *Encryption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Encryption)
	if !ok {
		that2, ok := that.(Encryption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TlsEnabled != that1.TlsEnabled {
		return false
	}
	if this.CertSecret != that1.CertSecret {
		return false
	}
	return true
}
func (this *Ingress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ingress)
	if !ok {
		that2, ok := that.(Ingress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Host) != len(that1.Host) {
		return false
	}
	for i := range this.Host {
		if !this.Host[i].Equal(that1.Host[i]) {
			return false
		}
	}
	return true
}
func (this *IngressHost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngressHost)
	if !ok {
		that2, ok := that.(IngressHost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if !this.Paths[i].Equal(that1.Paths[i]) {
			return false
		}
	}
	return true
}
func (this *Path) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Path)
	if !ok {
		that2, ok := that.(Path)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	return true
}
func (this *Destination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination)
	if !ok {
		that2, ok := that.(Destination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *Route) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route)
	if !ok {
		that2, ok := that.(Route)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	if this.Rewrite != that1.Rewrite {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if len(this.RoutePlugins) != len(that1.RoutePlugins) {
		return false
	}
	for i := range this.RoutePlugins {
		if !this.RoutePlugins[i].Equal(that1.RoutePlugins[i]) {
			return false
		}
	}
	return true
}
func (this *RoutePlugin) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutePlugin)
	if !ok {
		that2, ok := that.(RoutePlugin)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}

func init() { proto.RegisterFile("mesh.proto", fileDescriptorMesh) }

var fileDescriptorMesh = []byte{
	// 665 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0x5e, 0xd7, 0xf4, 0x67, 0x27, 0x1d, 0xda, 0xac, 0x09, 0x42, 0x11, 0xdb, 0x14, 0x2e, 0x98,
	0x26, 0x2d, 0x61, 0x05, 0x89, 0x31, 0x09, 0x09, 0x55, 0xab, 0xa0, 0x62, 0x83, 0xe2, 0xed, 0x0a,
	0x2e, 0x50, 0xda, 0x7a, 0x89, 0xb5, 0x34, 0x8e, 0x6c, 0x77, 0xd0, 0x37, 0xe2, 0x01, 0x78, 0x08,
	0x9e, 0x62, 0x17, 0xbc, 0x00, 0x12, 0x17, 0x5c, 0x23, 0x3b, 0x6e, 0x9b, 0xb1, 0x14, 0xc1, 0x55,
	0xec, 0x73, 0xbe, 0xef, 0x3b, 0x27, 0xdf, 0xb1, 0x0d, 0x30, 0x22, 0x22, 0xf2, 0x52, 0xce, 0x24,
	0x43, 0xeb, 0x62, 0x9c, 0x12, 0x1e, 0xc6, 0x8c, 0x79, 0x82, 0xc5, 0xcc, 0xa3, 0xac, 0xb9, 0x11,
	0xb2, 0x90, 0xe9, 0xac, 0xaf, 0x56, 0x19, 0xb0, 0xb9, 0x1f, 0x52, 0x19, 0x8d, 0xfb, 0xde, 0x80,
	0x8d, 0x7c, 0x85, 0xdc, 0xa3, 0x2c, 0xfb, 0x5e, 0x50, 0xe9, 0x07, 0x29, 0xf5, 0x2f, 0xf7, 0xfd,
	0x11, 0x91, 0xc1, 0x30, 0x90, 0x81, 0xa1, 0xf8, 0xff, 0x40, 0x11, 0x32, 0x90, 0x63, 0x91, 0x11,
	0xdc, 0x5f, 0xcb, 0x60, 0x9d, 0x10, 0x11, 0xa1, 0x23, 0x58, 0x55, 0x3d, 0x7e, 0x9c, 0x0a, 0x3a,
	0xa5, 0xed, 0xd2, 0x8e, 0xdd, 0xda, 0xf2, 0x6e, 0x74, 0xeb, 0x29, 0xfc, 0x89, 0x81, 0xe1, 0xc6,
	0x28, 0xb7, 0x43, 0xcf, 0x01, 0x48, 0x32, 0xe0, 0x93, 0x54, 0x52, 0x96, 0x38, 0xcb, 0x5a, 0xe2,
	0x7e, 0x81, 0x44, 0x67, 0x06, 0xc2, 0x39, 0x02, 0x7a, 0x02, 0x35, 0x9a, 0x84, 0x9c, 0x08, 0xe1,
	0x94, 0x35, 0xb7, 0x59, 0xc0, 0xed, 0x66, 0x08, 0x3c, 0x85, 0xa2, 0x47, 0x50, 0xe5, 0x6c, 0x2c,
	0x89, 0x70, 0xac, 0xed, 0xf2, 0x8e, 0xdd, 0x72, 0x0a, 0x48, 0x58, 0x01, 0xb0, 0xc1, 0xa1, 0x97,
	0x50, 0xcd, 0x5c, 0x70, 0xaa, 0xba, 0xcc, 0x86, 0x37, 0x60, 0x9c, 0xcc, 0xc0, 0xa7, 0x3a, 0xd7,
	0xbe, 0xfb, 0xed, 0x6a, 0x6b, 0xe9, 0xe7, 0xd5, 0xd6, 0xba, 0x24, 0x42, 0x0e, 0xe9, 0xf9, 0xf9,
	0xa1, 0x4b, 0xc3, 0x84, 0x71, 0xe2, 0x62, 0x43, 0x47, 0x07, 0x50, 0x9f, 0x19, 0x56, 0xd3, 0x52,
	0xb7, 0xaf, 0x4b, 0x4d, 0x9d, 0x69, 0x5b, 0x4a, 0x0c, 0xcf, 0xd0, 0xee, 0x07, 0x68, 0xe4, 0x7d,
	0x44, 0x08, 0xac, 0x24, 0x18, 0x11, 0x6d, 0xfb, 0x0a, 0xd6, 0x6b, 0xf4, 0x54, 0xa9, 0x8b, 0xe8,
	0x6c, 0x92, 0x12, 0xed, 0xe5, 0xad, 0xd6, 0xbd, 0x05, 0xe3, 0x50, 0x10, 0x3c, 0x03, 0xbb, 0xc7,
	0x00, 0x73, 0x87, 0xd1, 0x26, 0x80, 0x8c, 0x45, 0x27, 0x09, 0xfa, 0x31, 0x19, 0xea, 0x02, 0x75,
	0x9c, 0x8b, 0xa8, 0xfc, 0x80, 0x70, 0x79, 0x4a, 0x06, 0x9c, 0x48, 0x5d, 0x68, 0x05, 0xe7, 0x22,
	0xee, 0x3b, 0xa8, 0x19, 0xcf, 0x0b, 0xbb, 0x6c, 0x81, 0x15, 0x31, 0xa1, 0x88, 0xca, 0xfc, 0xcd,
	0xc5, 0x13, 0x7b, 0xc5, 0x84, 0xc4, 0x1a, 0xeb, 0xf6, 0xc0, 0xce, 0x05, 0x95, 0xac, 0x96, 0x30,
	0xb2, 0x6a, 0x8d, 0xf6, 0xa0, 0x92, 0x06, 0x32, 0x12, 0x46, 0xf7, 0x4e, 0x81, 0x6e, 0x2f, 0x90,
	0x11, 0xce, 0x50, 0x6e, 0x04, 0x96, 0xda, 0xaa, 0x9f, 0x51, 0x81, 0x1e, 0x27, 0xe7, 0xf4, 0xb3,
	0x11, 0xcc, 0x45, 0xd0, 0x0b, 0xb0, 0x87, 0x44, 0x48, 0x9a, 0x04, 0xb9, 0x23, 0x5a, 0xd4, 0xf4,
	0xd1, 0x1c, 0x85, 0xf3, 0x14, 0xf7, 0x6b, 0x09, 0xec, 0x5c, 0xb2, 0xd0, 0x13, 0x04, 0x56, 0xca,
	0x78, 0x66, 0x66, 0x05, 0xeb, 0x35, 0x6a, 0x43, 0x35, 0x0e, 0xfa, 0x24, 0x56, 0x67, 0x5b, 0xfd,
	0xd1, 0xee, 0xdf, 0x8b, 0x7a, 0xc7, 0x1a, 0xdc, 0x49, 0x24, 0x9f, 0x60, 0xc3, 0x6c, 0x3e, 0x03,
	0x3b, 0x17, 0x46, 0x6b, 0x50, 0xbe, 0x20, 0x13, 0x53, 0x59, 0x2d, 0xd1, 0x06, 0x54, 0x2e, 0x83,
	0x78, 0x4c, 0xcc, 0x18, 0xb3, 0xcd, 0xe1, 0xf2, 0x41, 0xc9, 0xfd, 0x51, 0x82, 0x8a, 0xbe, 0x05,
	0x8b, 0x1a, 0x36, 0x43, 0x9c, 0x4f, 0xe0, 0xba, 0x95, 0xe5, 0x1b, 0x56, 0x3a, 0x50, 0xe3, 0xe4,
	0x13, 0xa7, 0x92, 0x38, 0x96, 0x4e, 0x4e, 0xb7, 0x7f, 0x9a, 0x5c, 0xf9, 0x6f, 0x93, 0x51, 0x1b,
	0x1a, 0xfa, 0xae, 0xf6, 0xe2, 0x71, 0x48, 0x13, 0x75, 0x4f, 0x17, 0x1d, 0x2e, 0x3c, 0x87, 0xe1,
	0x6b, 0x1c, 0x77, 0x15, 0xec, 0x5c, 0x72, 0xf7, 0x01, 0xd4, 0xa7, 0x57, 0x05, 0xad, 0x40, 0xa5,
	0x7b, 0x7a, 0xd6, 0x7d, 0xbb, 0xb6, 0x84, 0x1a, 0x50, 0x3f, 0xee, 0xbe, 0x79, 0xdd, 0xc1, 0x47,
	0xfb, 0x6b, 0xa5, 0xf6, 0xde, 0x97, 0xef, 0x9b, 0xa5, 0xf7, 0x0f, 0x8b, 0x9e, 0xd1, 0x69, 0x65,
	0x3f, 0xbd, 0x08, 0xcd, 0x5b, 0xda, 0xaf, 0xea, 0x57, 0xf4, 0xf1, 0xef, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x24, 0x48, 0xc0, 0x45, 0xe0, 0x05, 0x00, 0x00,
}
