// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mesh.proto

package v1 // import "github.com/solo-io/supergloo/pkg/api/v1"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TODO: Eventually we want to plug in new meshes easier, but for now it's useful to enumerate in the config
type MeshType int32

const (
	MeshType_ISTIO    MeshType = 0
	MeshType_LINKERD1 MeshType = 1
)

var MeshType_name = map[int32]string{
	0: "ISTIO",
	1: "LINKERD1",
}
var MeshType_value = map[string]int32{
	"ISTIO":    0,
	"LINKERD1": 1,
}

func (x MeshType) String() string {
	return proto.EnumName(MeshType_name, int32(x))
}
func (MeshType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mesh_e49a5dc034cc67c7, []int{0}
}

// Any user-configurable settings for a service mesh
type MeshConfig struct {
	MeshType             MeshType    `protobuf:"varint,1,opt,name=meshType,proto3,enum=supergloo.solo.io.MeshType" json:"meshType,omitempty"`
	Encryption           *Encryption `protobuf:"bytes,2,opt,name=encryption" json:"encryption,omitempty"`
	Ingress              *Ingress    `protobuf:"bytes,3,opt,name=ingress" json:"ingress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MeshConfig) Reset()         { *m = MeshConfig{} }
func (m *MeshConfig) String() string { return proto.CompactTextString(m) }
func (*MeshConfig) ProtoMessage()    {}
func (*MeshConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_mesh_e49a5dc034cc67c7, []int{0}
}
func (m *MeshConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MeshConfig.Unmarshal(m, b)
}
func (m *MeshConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MeshConfig.Marshal(b, m, deterministic)
}
func (dst *MeshConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeshConfig.Merge(dst, src)
}
func (m *MeshConfig) XXX_Size() int {
	return xxx_messageInfo_MeshConfig.Size(m)
}
func (m *MeshConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MeshConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MeshConfig proto.InternalMessageInfo

func (m *MeshConfig) GetMeshType() MeshType {
	if m != nil {
		return m.MeshType
	}
	return MeshType_ISTIO
}

func (m *MeshConfig) GetEncryption() *Encryption {
	if m != nil {
		return m.Encryption
	}
	return nil
}

func (m *MeshConfig) GetIngress() *Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

// Defines mesh-level configuration for encryption. Supports communication within a mesh and through ingress.
// Communicating between TLS and non-TLS enabled services is not supported. TODO: Is this ok?
// TODO: What do we need to support communication across mesh?
type Encryption struct {
	// If set to true, TLS is enabled across the entire mesh.
	TlsEnabled bool `protobuf:"varint,1,opt,name=tlsEnabled,proto3" json:"tlsEnabled,omitempty"`
	// If TLS is enabled, this is the name of the secret containing the certs.
	// When using Istio, this should either be "istio.default", meaning Istio is using the default Citadel cert
	// generation, or "cacert", which is a custom-uploaded Kubernetes secret containing all the cert files.
	// When using Linkerd, this is the name of a secret that will be mounted into the linkerd Kubernetes DaemonSet.
	CertSecret           string   `protobuf:"bytes,2,opt,name=certSecret,proto3" json:"certSecret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Encryption) Reset()         { *m = Encryption{} }
func (m *Encryption) String() string { return proto.CompactTextString(m) }
func (*Encryption) ProtoMessage()    {}
func (*Encryption) Descriptor() ([]byte, []int) {
	return fileDescriptor_mesh_e49a5dc034cc67c7, []int{1}
}
func (m *Encryption) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Encryption.Unmarshal(m, b)
}
func (m *Encryption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Encryption.Marshal(b, m, deterministic)
}
func (dst *Encryption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Encryption.Merge(dst, src)
}
func (m *Encryption) XXX_Size() int {
	return xxx_messageInfo_Encryption.Size(m)
}
func (m *Encryption) XXX_DiscardUnknown() {
	xxx_messageInfo_Encryption.DiscardUnknown(m)
}

var xxx_messageInfo_Encryption proto.InternalMessageInfo

func (m *Encryption) GetTlsEnabled() bool {
	if m != nil {
		return m.TlsEnabled
	}
	return false
}

func (m *Encryption) GetCertSecret() string {
	if m != nil {
		return m.CertSecret
	}
	return ""
}

type Ingress struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ingress) Reset()         { *m = Ingress{} }
func (m *Ingress) String() string { return proto.CompactTextString(m) }
func (*Ingress) ProtoMessage()    {}
func (*Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_mesh_e49a5dc034cc67c7, []int{2}
}
func (m *Ingress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ingress.Unmarshal(m, b)
}
func (m *Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ingress.Marshal(b, m, deterministic)
}
func (dst *Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingress.Merge(dst, src)
}
func (m *Ingress) XXX_Size() int {
	return xxx_messageInfo_Ingress.Size(m)
}
func (m *Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Ingress proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MeshConfig)(nil), "supergloo.solo.io.MeshConfig")
	proto.RegisterType((*Encryption)(nil), "supergloo.solo.io.Encryption")
	proto.RegisterType((*Ingress)(nil), "supergloo.solo.io.Ingress")
	proto.RegisterEnum("supergloo.solo.io.MeshType", MeshType_name, MeshType_value)
}
func (this *MeshConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeshConfig)
	if !ok {
		that2, ok := that.(MeshConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MeshType != that1.MeshType {
		return false
	}
	if !this.Encryption.Equal(that1.Encryption) {
		return false
	}
	if !this.Ingress.Equal(that1.Ingress) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Encryption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Encryption)
	if !ok {
		that2, ok := that.(Encryption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TlsEnabled != that1.TlsEnabled {
		return false
	}
	if this.CertSecret != that1.CertSecret {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Ingress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ingress)
	if !ok {
		that2, ok := that.(Ingress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

func init() { proto.RegisterFile("mesh.proto", fileDescriptor_mesh_e49a5dc034cc67c7) }

var fileDescriptor_mesh_e49a5dc034cc67c7 = []byte{
	// 289 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x90, 0x41, 0x4e, 0x02, 0x31,
	0x14, 0x86, 0xad, 0x46, 0x19, 0x9e, 0xc6, 0x60, 0xe3, 0x82, 0x60, 0x24, 0x04, 0x17, 0x12, 0x13,
	0xda, 0x80, 0x26, 0xae, 0xdc, 0xa8, 0x2c, 0x26, 0x82, 0x26, 0x85, 0x95, 0x3b, 0x18, 0x6b, 0xa7,
	0x71, 0x98, 0xd7, 0xb4, 0xc5, 0x84, 0x1b, 0x79, 0x06, 0x8f, 0xe3, 0x49, 0xcc, 0x0c, 0x30, 0x4e,
	0x22, 0xbb, 0xe6, 0xbd, 0xef, 0xff, 0xfb, 0xb5, 0x00, 0x73, 0xe9, 0x62, 0x66, 0x2c, 0x7a, 0xa4,
	0x27, 0x6e, 0x61, 0xa4, 0x55, 0x09, 0x22, 0x73, 0x98, 0x20, 0xd3, 0xd8, 0x38, 0x55, 0xa8, 0x30,
	0xdf, 0xf2, 0xec, 0xb4, 0x02, 0xdb, 0xdf, 0x04, 0x60, 0x24, 0x5d, 0xfc, 0x80, 0xe9, 0xbb, 0x56,
	0xf4, 0x16, 0x82, 0xac, 0x65, 0xb2, 0x34, 0xb2, 0x4e, 0x5a, 0xa4, 0x73, 0xdc, 0x3f, 0x63, 0xff,
	0xaa, 0xd8, 0x68, 0x8d, 0x88, 0x02, 0xa6, 0x77, 0x00, 0x32, 0x8d, 0xec, 0xd2, 0x78, 0x8d, 0x69,
	0x7d, 0xb7, 0x45, 0x3a, 0x87, 0xfd, 0xf3, 0x2d, 0xd1, 0x41, 0x01, 0x89, 0x52, 0x80, 0xde, 0x40,
	0x45, 0xa7, 0xca, 0x4a, 0xe7, 0xea, 0x7b, 0x79, 0xb6, 0xb1, 0x25, 0x1b, 0xae, 0x08, 0xb1, 0x41,
	0xdb, 0x43, 0x80, 0xbf, 0x3e, 0xda, 0x04, 0xf0, 0x89, 0x1b, 0xa4, 0xd3, 0x59, 0x22, 0xdf, 0x72,
	0xfb, 0x40, 0x94, 0x26, 0xd9, 0x3e, 0x92, 0xd6, 0x8f, 0x65, 0x64, 0xa5, 0xcf, 0x15, 0xab, 0xa2,
	0x34, 0x69, 0x57, 0xa1, 0xb2, 0xbe, 0xe1, 0xea, 0x02, 0x82, 0xcd, 0x1b, 0x69, 0x15, 0xf6, 0xc3,
	0xf1, 0x24, 0x7c, 0xa9, 0xed, 0xd0, 0x23, 0x08, 0x86, 0xe1, 0xf3, 0xd3, 0x40, 0x3c, 0xf6, 0x6a,
	0xe4, 0xbe, 0xfb, 0xf5, 0xd3, 0x24, 0xaf, 0x97, 0x4a, 0xfb, 0x78, 0x31, 0x63, 0x11, 0xce, 0x79,
	0x26, 0xda, 0xd5, 0xc8, 0x0b, 0x75, 0x6e, 0x3e, 0x14, 0x9f, 0x1a, 0xcd, 0x3f, 0x7b, 0xb3, 0x83,
	0xfc, 0xc3, 0xaf, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x43, 0xad, 0x6b, 0x83, 0xa7, 0x01, 0x00,
	0x00,
}
