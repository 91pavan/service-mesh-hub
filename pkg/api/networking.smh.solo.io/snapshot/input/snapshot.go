// Code generated by skv2. DO NOT EDIT.

// The Input Snapshot contains the set of all:
// * MeshServices
// * MeshWorkloads
// * Meshes
// * TrafficPolicies
// * AccessPolicies
// * VirtualMeshes
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"

	"github.com/hashicorp/go-multierror"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"

	discovery_smh_solo_io_v1alpha1 "github.com/solo-io/service-mesh-hub/pkg/api/discovery.smh.solo.io/v1alpha1"
	discovery_smh_solo_io_v1alpha1_sets "github.com/solo-io/service-mesh-hub/pkg/api/discovery.smh.solo.io/v1alpha1/sets"

	networking_smh_solo_io_v1alpha1 "github.com/solo-io/service-mesh-hub/pkg/api/networking.smh.solo.io/v1alpha1"
	networking_smh_solo_io_v1alpha1_sets "github.com/solo-io/service-mesh-hub/pkg/api/networking.smh.solo.io/v1alpha1/sets"
)

// the snapshot of input resources consumed by translation
type Snapshot interface {

	// return the set of input MeshServices
	MeshServices() discovery_smh_solo_io_v1alpha1_sets.MeshServiceSet
	// return the set of input MeshWorkloads
	MeshWorkloads() discovery_smh_solo_io_v1alpha1_sets.MeshWorkloadSet
	// return the set of input Meshes
	Meshes() discovery_smh_solo_io_v1alpha1_sets.MeshSet

	// return the set of input TrafficPolicies
	TrafficPolicies() networking_smh_solo_io_v1alpha1_sets.TrafficPolicySet
	// return the set of input AccessPolicies
	AccessPolicies() networking_smh_solo_io_v1alpha1_sets.AccessPolicySet
	// return the set of input VirtualMeshes
	VirtualMeshes() networking_smh_solo_io_v1alpha1_sets.VirtualMeshSet
}

type snapshot struct {
	name string

	meshServices  discovery_smh_solo_io_v1alpha1_sets.MeshServiceSet
	meshWorkloads discovery_smh_solo_io_v1alpha1_sets.MeshWorkloadSet
	meshes        discovery_smh_solo_io_v1alpha1_sets.MeshSet

	trafficPolicies networking_smh_solo_io_v1alpha1_sets.TrafficPolicySet
	accessPolicies  networking_smh_solo_io_v1alpha1_sets.AccessPolicySet
	virtualMeshes   networking_smh_solo_io_v1alpha1_sets.VirtualMeshSet
}

func NewSnapshot(
	name string,

	meshServices discovery_smh_solo_io_v1alpha1_sets.MeshServiceSet,
	meshWorkloads discovery_smh_solo_io_v1alpha1_sets.MeshWorkloadSet,
	meshes discovery_smh_solo_io_v1alpha1_sets.MeshSet,

	trafficPolicies networking_smh_solo_io_v1alpha1_sets.TrafficPolicySet,
	accessPolicies networking_smh_solo_io_v1alpha1_sets.AccessPolicySet,
	virtualMeshes networking_smh_solo_io_v1alpha1_sets.VirtualMeshSet,

) Snapshot {
	return &snapshot{
		name: name,

		meshServices:    meshServices,
		meshWorkloads:   meshWorkloads,
		meshes:          meshes,
		trafficPolicies: trafficPolicies,
		accessPolicies:  accessPolicies,
		virtualMeshes:   virtualMeshes,
	}
}

func (s snapshot) MeshServices() discovery_smh_solo_io_v1alpha1_sets.MeshServiceSet {
	return s.meshServices
}

func (s snapshot) MeshWorkloads() discovery_smh_solo_io_v1alpha1_sets.MeshWorkloadSet {
	return s.meshWorkloads
}

func (s snapshot) Meshes() discovery_smh_solo_io_v1alpha1_sets.MeshSet {
	return s.meshes
}

func (s snapshot) TrafficPolicies() networking_smh_solo_io_v1alpha1_sets.TrafficPolicySet {
	return s.trafficPolicies
}

func (s snapshot) AccessPolicies() networking_smh_solo_io_v1alpha1_sets.AccessPolicySet {
	return s.accessPolicies
}

func (s snapshot) VirtualMeshes() networking_smh_solo_io_v1alpha1_sets.VirtualMeshSet {
	return s.virtualMeshes
}

// builds the input snapshot from API Clients.
// Two types of builders are available:
// a builder for snapshots of resources across multiple clusters
// a builder for snapshots of resources within a single cluster
type Builder interface {
	BuildSnapshot(ctx context.Context, name string) (Snapshot, error)
}

// build a snapshot from resources across multiple clusters
type multiClusterBuilder struct {
	clusters multicluster.ClusterSet

	meshServices  discovery_smh_solo_io_v1alpha1.MulticlusterMeshServiceClient
	meshWorkloads discovery_smh_solo_io_v1alpha1.MulticlusterMeshWorkloadClient
	meshes        discovery_smh_solo_io_v1alpha1.MulticlusterMeshClient

	trafficPolicies networking_smh_solo_io_v1alpha1.MulticlusterTrafficPolicyClient
	accessPolicies  networking_smh_solo_io_v1alpha1.MulticlusterAccessPolicyClient
	virtualMeshes   networking_smh_solo_io_v1alpha1.MulticlusterVirtualMeshClient
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterBuilder(
	clusters multicluster.ClusterSet,
	client multicluster.Client,
) Builder {
	return &multiClusterBuilder{
		clusters: clusters,

		meshServices:  discovery_smh_solo_io_v1alpha1.NewMulticlusterMeshServiceClient(client),
		meshWorkloads: discovery_smh_solo_io_v1alpha1.NewMulticlusterMeshWorkloadClient(client),
		meshes:        discovery_smh_solo_io_v1alpha1.NewMulticlusterMeshClient(client),

		trafficPolicies: networking_smh_solo_io_v1alpha1.NewMulticlusterTrafficPolicyClient(client),
		accessPolicies:  networking_smh_solo_io_v1alpha1.NewMulticlusterAccessPolicyClient(client),
		virtualMeshes:   networking_smh_solo_io_v1alpha1.NewMulticlusterVirtualMeshClient(client),
	}
}

func (b *multiClusterBuilder) BuildSnapshot(ctx context.Context, name string) (Snapshot, error) {

	meshServices := discovery_smh_solo_io_v1alpha1_sets.NewMeshServiceSet()
	meshWorkloads := discovery_smh_solo_io_v1alpha1_sets.NewMeshWorkloadSet()
	meshes := discovery_smh_solo_io_v1alpha1_sets.NewMeshSet()

	trafficPolicies := networking_smh_solo_io_v1alpha1_sets.NewTrafficPolicySet()
	accessPolicies := networking_smh_solo_io_v1alpha1_sets.NewAccessPolicySet()
	virtualMeshes := networking_smh_solo_io_v1alpha1_sets.NewVirtualMeshSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertMeshServicesFromCluster(ctx, cluster, meshServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertMeshWorkloadsFromCluster(ctx, cluster, meshWorkloads); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertMeshesFromCluster(ctx, cluster, meshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertTrafficPoliciesFromCluster(ctx, cluster, trafficPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAccessPoliciesFromCluster(ctx, cluster, accessPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualMeshesFromCluster(ctx, cluster, virtualMeshes); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewSnapshot(
		name,

		meshServices,
		meshWorkloads,
		meshes,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
	)

	return outputSnap, errs
}

func (b *multiClusterBuilder) insertMeshServicesFromCluster(ctx context.Context, cluster string, meshServices discovery_smh_solo_io_v1alpha1_sets.MeshServiceSet) error {
	meshServiceClient, err := b.meshServices.Cluster(cluster)
	if err != nil {
		return err
	}

	meshServiceList, err := meshServiceClient.ListMeshService(ctx)
	if err != nil {
		return err
	}

	for _, item := range meshServiceList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		meshServices.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertMeshWorkloadsFromCluster(ctx context.Context, cluster string, meshWorkloads discovery_smh_solo_io_v1alpha1_sets.MeshWorkloadSet) error {
	meshWorkloadClient, err := b.meshWorkloads.Cluster(cluster)
	if err != nil {
		return err
	}

	meshWorkloadList, err := meshWorkloadClient.ListMeshWorkload(ctx)
	if err != nil {
		return err
	}

	for _, item := range meshWorkloadList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		meshWorkloads.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertMeshesFromCluster(ctx context.Context, cluster string, meshes discovery_smh_solo_io_v1alpha1_sets.MeshSet) error {
	meshClient, err := b.meshes.Cluster(cluster)
	if err != nil {
		return err
	}

	meshList, err := meshClient.ListMesh(ctx)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		meshes.Insert(&item)
	}

	return nil
}

func (b *multiClusterBuilder) insertTrafficPoliciesFromCluster(ctx context.Context, cluster string, trafficPolicies networking_smh_solo_io_v1alpha1_sets.TrafficPolicySet) error {
	trafficPolicyClient, err := b.trafficPolicies.Cluster(cluster)
	if err != nil {
		return err
	}

	trafficPolicyList, err := trafficPolicyClient.ListTrafficPolicy(ctx)
	if err != nil {
		return err
	}

	for _, item := range trafficPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		trafficPolicies.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertAccessPoliciesFromCluster(ctx context.Context, cluster string, accessPolicies networking_smh_solo_io_v1alpha1_sets.AccessPolicySet) error {
	accessPolicyClient, err := b.accessPolicies.Cluster(cluster)
	if err != nil {
		return err
	}

	accessPolicyList, err := accessPolicyClient.ListAccessPolicy(ctx)
	if err != nil {
		return err
	}

	for _, item := range accessPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		accessPolicies.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertVirtualMeshesFromCluster(ctx context.Context, cluster string, virtualMeshes networking_smh_solo_io_v1alpha1_sets.VirtualMeshSet) error {
	virtualMeshClient, err := b.virtualMeshes.Cluster(cluster)
	if err != nil {
		return err
	}

	virtualMeshList, err := virtualMeshClient.ListVirtualMesh(ctx)
	if err != nil {
		return err
	}

	for _, item := range virtualMeshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualMeshes.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterBuilder struct {
	meshServices  discovery_smh_solo_io_v1alpha1.MeshServiceClient
	meshWorkloads discovery_smh_solo_io_v1alpha1.MeshWorkloadClient
	meshes        discovery_smh_solo_io_v1alpha1.MeshClient

	trafficPolicies networking_smh_solo_io_v1alpha1.TrafficPolicyClient
	accessPolicies  networking_smh_solo_io_v1alpha1.AccessPolicyClient
	virtualMeshes   networking_smh_solo_io_v1alpha1.VirtualMeshClient
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewSingleClusterBuilder(
	client client.Client,
) Builder {
	return &singleClusterBuilder{

		meshServices:  discovery_smh_solo_io_v1alpha1.NewMeshServiceClient(client),
		meshWorkloads: discovery_smh_solo_io_v1alpha1.NewMeshWorkloadClient(client),
		meshes:        discovery_smh_solo_io_v1alpha1.NewMeshClient(client),

		trafficPolicies: networking_smh_solo_io_v1alpha1.NewTrafficPolicyClient(client),
		accessPolicies:  networking_smh_solo_io_v1alpha1.NewAccessPolicyClient(client),
		virtualMeshes:   networking_smh_solo_io_v1alpha1.NewVirtualMeshClient(client),
	}
}

func (b *singleClusterBuilder) BuildSnapshot(ctx context.Context, name string) (Snapshot, error) {

	meshServices := discovery_smh_solo_io_v1alpha1_sets.NewMeshServiceSet()
	meshWorkloads := discovery_smh_solo_io_v1alpha1_sets.NewMeshWorkloadSet()
	meshes := discovery_smh_solo_io_v1alpha1_sets.NewMeshSet()

	trafficPolicies := networking_smh_solo_io_v1alpha1_sets.NewTrafficPolicySet()
	accessPolicies := networking_smh_solo_io_v1alpha1_sets.NewAccessPolicySet()
	virtualMeshes := networking_smh_solo_io_v1alpha1_sets.NewVirtualMeshSet()

	var errs error

	if err := b.insertMeshServices(ctx, meshServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertMeshWorkloads(ctx, meshWorkloads); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertMeshes(ctx, meshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertTrafficPolicies(ctx, trafficPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAccessPolicies(ctx, accessPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualMeshes(ctx, virtualMeshes); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSnapshot(
		name,

		meshServices,
		meshWorkloads,
		meshes,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
	)

	return outputSnap, errs
}

func (b *singleClusterBuilder) insertMeshServices(ctx context.Context, meshServices discovery_smh_solo_io_v1alpha1_sets.MeshServiceSet) error {
	meshServiceList, err := b.meshServices.ListMeshService(ctx)
	if err != nil {
		return err
	}

	for _, item := range meshServiceList.Items {
		item := item // pike
		meshServices.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertMeshWorkloads(ctx context.Context, meshWorkloads discovery_smh_solo_io_v1alpha1_sets.MeshWorkloadSet) error {
	meshWorkloadList, err := b.meshWorkloads.ListMeshWorkload(ctx)
	if err != nil {
		return err
	}

	for _, item := range meshWorkloadList.Items {
		item := item // pike
		meshWorkloads.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertMeshes(ctx context.Context, meshes discovery_smh_solo_io_v1alpha1_sets.MeshSet) error {
	meshList, err := b.meshes.ListMesh(ctx)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item // pike
		meshes.Insert(&item)
	}

	return nil
}

func (b *singleClusterBuilder) insertTrafficPolicies(ctx context.Context, trafficPolicies networking_smh_solo_io_v1alpha1_sets.TrafficPolicySet) error {
	trafficPolicyList, err := b.trafficPolicies.ListTrafficPolicy(ctx)
	if err != nil {
		return err
	}

	for _, item := range trafficPolicyList.Items {
		item := item // pike
		trafficPolicies.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertAccessPolicies(ctx context.Context, accessPolicies networking_smh_solo_io_v1alpha1_sets.AccessPolicySet) error {
	accessPolicyList, err := b.accessPolicies.ListAccessPolicy(ctx)
	if err != nil {
		return err
	}

	for _, item := range accessPolicyList.Items {
		item := item // pike
		accessPolicies.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertVirtualMeshes(ctx context.Context, virtualMeshes networking_smh_solo_io_v1alpha1_sets.VirtualMeshSet) error {
	virtualMeshList, err := b.virtualMeshes.ListVirtualMesh(ctx)
	if err != nil {
		return err
	}

	for _, item := range virtualMeshList.Items {
		item := item // pike
		virtualMeshes.Insert(&item)
	}

	return nil
}
