// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/mesh-projects/api/external/istio/rbac/v1alpha1/rbac.proto

//// $title: RBAC
//// $description: Configuration for Role Based Access Control.
//// $location: https://istio.io/docs/reference/config/authorization/istio.rbac.v1alpha1.html
//
//// Istio RBAC (Role Based Access Control) defines ServiceRole and ServiceRoleBinding
//// objects.
////
//// A ServiceRole specification includes a list of rules (permissions). Each rule has
//// the following standard fields:
////
////   * services: a list of services.
////   * methods: A list of HTTP methods. You can set the value to `*` to include all HTTP methods.
////              This field should not be set for TCP services. The policy will be ignored.
////              For gRPC services, only `POST` is allowed; other methods will result in denying services.
////   * paths: HTTP paths or gRPC methods. Note that gRPC methods should be
////     presented in the form of "/packageName.serviceName/methodName" and are case sensitive.
////
//// In addition to the standard fields, operators can also use custom keys in the `constraints` field,
//// the supported keys are listed in the "constraints and properties" page.
////
//// Below is an example of ServiceRole object "product-viewer", which has "read" ("GET" and "HEAD")
//// access to "products.svc.cluster.local" service at versions "v1" and "v2". "path" is not specified,
//// so it applies to any path in the service.
////
//// ```yaml
//// apiVersion: "rbac.istio.io/v1alpha1"
//// kind: ServiceRole
//// metadata:
////   name: products-viewer
////   namespace: default
//// spec:
////   rules:
////   - services: ["products.svc.cluster.local"]
////     methods: ["GET", "HEAD"]
////     constraints:
////     - key: "destination.labels[version]"
////       values: ["v1", "v2"]
//// ```
////
//// A ServiceRoleBinding specification includes two parts:
////
////  * The `roleRef` field that refers to a ServiceRole object in the same namespace.
////  * A list of `subjects` that are assigned the roles.
////
//// In addition to a simple `user` field, operators can also use custom keys in the `properties` field,
//// the supported keys are listed in the "constraints and properties" page.
////
//// Below is an example of ServiceRoleBinding object "test-binding-products", which binds two subjects
//// to ServiceRole "product-viewer":
////
////   * User "alice@yahoo.com"
////   * Services in "abc" namespace.
////
//// ```yaml
//// apiVersion: "rbac.istio.io/v1alpha1"
//// kind: ServiceRoleBinding
//// metadata:
////   name: test-binding-products
////   namespace: default
//// spec:
////   subjects:
////   - user: alice@yahoo.com
////   - properties:
////       source.namespace: "abc"
////   roleRef:
////     kind: ServiceRole
////     name: "products-viewer"
//// ```

package v1alpha1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// $hide_from_docs
// RBAC ServiceRoleBinding enforcement mode, used to verify new ServiceRoleBinding
// configs work as expected before rolling to production. RBAC engine only logs results
// from configs that are in permissive mode, and discards result before returning
// to the user.
type EnforcementMode int32

const (
	// Policy in ENFORCED mode has impact on user experience.
	// Policy is in ENFORCED mode by default.
	EnforcementMode_ENFORCED EnforcementMode = 0
	// Policy in PERMISSIVE mode isn't enforced and has no impact on users.
	// RBAC engine run policies in PERMISSIVE mode and logs stats.
	EnforcementMode_PERMISSIVE EnforcementMode = 1
)

var EnforcementMode_name = map[int32]string{
	0: "ENFORCED",
	1: "PERMISSIVE",
}

var EnforcementMode_value = map[string]int32{
	"ENFORCED":   0,
	"PERMISSIVE": 1,
}

func (x EnforcementMode) String() string {
	return proto.EnumName(EnforcementMode_name, int32(x))
}

func (EnforcementMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_74695df94c167244, []int{0}
}

type RbacConfig_Mode int32

const (
	// Disable Istio RBAC completely, Istio RBAC policies will not be enforced.
	RbacConfig_OFF RbacConfig_Mode = 0
	// Enable Istio RBAC for all services and namespaces. Note Istio RBAC is deny-by-default
	// which means all requests will be denied if it's not allowed by RBAC rules.
	RbacConfig_ON RbacConfig_Mode = 1
	// Enable Istio RBAC only for services and namespaces specified in the inclusion field. Any other
	// services and namespaces not in the inclusion field will not be enforced by Istio RBAC policies.
	RbacConfig_ON_WITH_INCLUSION RbacConfig_Mode = 2
	// Enable Istio RBAC for all services and namespaces except those specified in the exclusion field. Any other
	// services and namespaces not in the exclusion field will be enforced by Istio RBAC policies.
	RbacConfig_ON_WITH_EXCLUSION RbacConfig_Mode = 3
)

var RbacConfig_Mode_name = map[int32]string{
	0: "OFF",
	1: "ON",
	2: "ON_WITH_INCLUSION",
	3: "ON_WITH_EXCLUSION",
}

var RbacConfig_Mode_value = map[string]int32{
	"OFF":               0,
	"ON":                1,
	"ON_WITH_INCLUSION": 2,
	"ON_WITH_EXCLUSION": 3,
}

func (x RbacConfig_Mode) String() string {
	return proto.EnumName(RbacConfig_Mode_name, int32(x))
}

func (RbacConfig_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_74695df94c167244, []int{0, 0}
}

//// ServiceRoleBinding assigns a ServiceRole to a list of subjects.
//message ServiceRoleBinding {
//    // Required. List of subjects that are assigned the ServiceRole object.
//    repeated Subject subjects = 1;
//
//    // Required. Reference to the ServiceRole object.
//    RoleRef roleRef = 2;
//
//    // $hide_from_docs
//    // Indicates enforcement mode of the ServiceRoleBinding.
//    EnforcementMode mode = 3;
//
//    // $hide_from_docs
//    // Inline role definition. An inline role is a role that is defined inside an
//    // authorization policy, instead of explicitly defined in a ServiceRole object.
//    // Inline roles can be used for the role definitions that are not intended to
//    // be reused in other bindings, while explicit roles are reusable. Both inline
//    // roles (defined in "actions" field) and explicit roles (defined in ServiceRole)
//    // are supported. Users should use only one of them in a single binding.
//    // For example, the following “product-frontend” AuthorizationPolicy allows “frontend”
//    // service to view “product” service on “/info” path.
//    // ```yaml
//    // apiVersion: "rbac.istio.io/v1alpha1"
//    // kind: AuthorizationPolicy
//    // metadata:
//    //  name: product-frontend
//    //  namespace: ns1
//    // spec:
//    //  selector:
//    //    labels:
//    //      app: product
//    //  allow:
//    //  - subjects:
//    //    - names: ["cluster.local/ns/default/sa/frontend"]
//    //    actions:
//    //    - paths: ["/info"]
//    //      methods: ["GET"]
//    // Required. The set of access rules (permissions) that the role has.
//    repeated AccessRule actions = 4;
//
//    // $hide_from_docs
//    // A `role` inside a ServiceRoleBinding refers to the ServiceRole that this
//    // ServiceRoleBinding binds to. A ServiceRoleBinding can bind to a ServiceRole
//    // in the same namespace or the root namespace. A ServiceRole in the root namespace
//    // represents a mesh global ServiceRole.
//    // The value of `role` is the name of the ServiceRole, and it can start with or without a forward slash ("/").
//    // When a `role` starts with "/", e.g. "/service-viewer", it means that this ServiceRoleBinding
//    // refers to the ServiceRole in the configurable Istio root namespace.
//    // When a `role` starts without "/", this ServiceRoleBinding refers to the ServiceRole in the
//    // same namespace as the AuthorizationPolicy's, which contains said ServiceRoleBinding.
//    string role = 5;
//}
//
//// Subject defines an identity. The identity is either a user or identified by a set of `properties`.
//// The supported keys in `properties` are listed in "constraint and properties" page.
//message Subject {
//    // Optional. The user name/ID that the subject represents.
//    string user = 1;
//
//    // $hide_from_docs
//    // Optional. A list of subject names. This is matched to the
//    // `source.principal` attribute. If one of subject names is "*", it matches to a subject with any name.
//    // Prefix and suffix matches are supported.
//    repeated string names = 4;
//
//    // $hide_from_docs
//    // Optional. A list of subject names that must not be matched.
//    repeated string not_names = 5;
//
//    // $hide_from_docs
//    // Optional. The group that the subject belongs to.
//    // Deprecated. Use groups and not_groups instead.
//    string group = 2 [deprecated = true];
//
//    // $hide_from_docs
//    // Optional. A list of groups that the subject represents. This is matched to the
//    // `request.auth.claims[groups]` attribute. If not specified, it applies to any groups.
//    repeated string groups = 6;
//
//    // $hide_from_docs
//    // Optional. A list of groups that must not be matched.
//    repeated string not_groups = 7;
//
//    // $hide_from_docs
//    // Optional. A list of namespaces that the subject represents. This is matched to
//    // the `source.namespace` attribute. If not specified, it applies to any namespaces.
//    repeated string namespaces = 8;
//
//    // $hide_from_docs
//    // Optional. A list of namespaces that must not be matched.
//    repeated string not_namespaces = 9;
//
//    // $hide_from_docs
//    // Optional. A list of IP address or CIDR ranges that the subject represents.
//    // E.g. 192.168.100.2 or 10.1.0.0/16. If not specified, it applies to any IP addresses.
//    repeated string ips = 10;
//
//    // $hide_from_docs
//    // Optional. A list of IP addresses or CIDR ranges that must not be matched.
//    repeated string not_ips = 11;
//
//    // Optional. The set of properties that identify the subject.
//    map<string, string> properties = 3;
//
//    // $hide_from_docs
//    // Next available field number: 12
//}
//
//// RoleRef refers to a role object.
//message RoleRef {
//    // Required. The type of the role being referenced.
//    // Currently, "ServiceRole" is the only supported value for "kind".
//    string kind = 1;
//
//    // Required. The name of the ServiceRole object being referenced.
//    // The ServiceRole object must be in the same namespace as the ServiceRoleBinding object.
//    string name = 2;
//}
//
//// RbacConfig implements the ClusterRbaConfig Custom Resource Definition for controlling Istio RBAC behavior.
//// The ClusterRbaConfig Custom Resource is a singleton where only one ClusterRbaConfig should be created
//// globally in the mesh and the namespace should be the same to other Istio components, which usually is `istio-system`.
////
//// Below is an example of an `ClusterRbacConfig` resource called `istio-rbac-config` which enables Istio RBAC for all
//// services in the default namespace.
////
//// ```yaml
//// apiVersion: "rbac.istio.io/v1alpha1"
//// kind: ClusterRbacConfig
//// metadata:
////   name: default
////   namespace: istio-system
//// spec:
////   mode: ON_WITH_INCLUSION
////   inclusion:
////     namespaces: [ "default" ]
//// ```
type RbacConfig struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by operator during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata,proto3" json:"metadata"`
	// Istio RBAC mode.
	Mode RbacConfig_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=istio.rbac.v1alpha1.RbacConfig_Mode" json:"mode,omitempty"`
	// A list of services or namespaces that should be enforced by Istio RBAC policies. Note: This field have
	// effect only when mode is ON_WITH_INCLUSION and will be ignored for any other modes.
	Inclusion *RbacConfig_Target `protobuf:"bytes,2,opt,name=inclusion,proto3" json:"inclusion,omitempty"`
	// A list of services or namespaces that should not be enforced by Istio RBAC policies. Note: This field have
	// effect only when mode is ON_WITH_EXCLUSION and will be ignored for any other modes.
	Exclusion *RbacConfig_Target `protobuf:"bytes,3,opt,name=exclusion,proto3" json:"exclusion,omitempty"`
	// $hide_from_docs
	// Indicates enforcement mode of the RbacConfig, in ENFORCED mode by default.
	// It's used to verify new RbacConfig work as expected before rolling to production.
	// When setting as PERMISSIVE, RBAC isn't enforced and has no impact on users.
	// RBAC engine run RbacConfig in PERMISSIVE mode and logs stats.
	// Invalid to set RbacConfig in PERMISSIVE and ServiceRoleBinding in ENFORCED mode.
	EnforcementMode      EnforcementMode `protobuf:"varint,4,opt,name=enforcement_mode,json=enforcementMode,proto3,enum=istio.rbac.v1alpha1.EnforcementMode" json:"enforcement_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RbacConfig) Reset()         { *m = RbacConfig{} }
func (m *RbacConfig) String() string { return proto.CompactTextString(m) }
func (*RbacConfig) ProtoMessage()    {}
func (*RbacConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_74695df94c167244, []int{0}
}
func (m *RbacConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RbacConfig.Unmarshal(m, b)
}
func (m *RbacConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RbacConfig.Marshal(b, m, deterministic)
}
func (m *RbacConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RbacConfig.Merge(m, src)
}
func (m *RbacConfig) XXX_Size() int {
	return xxx_messageInfo_RbacConfig.Size(m)
}
func (m *RbacConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RbacConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RbacConfig proto.InternalMessageInfo

func (m *RbacConfig) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *RbacConfig) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *RbacConfig) GetMode() RbacConfig_Mode {
	if m != nil {
		return m.Mode
	}
	return RbacConfig_OFF
}

func (m *RbacConfig) GetInclusion() *RbacConfig_Target {
	if m != nil {
		return m.Inclusion
	}
	return nil
}

func (m *RbacConfig) GetExclusion() *RbacConfig_Target {
	if m != nil {
		return m.Exclusion
	}
	return nil
}

func (m *RbacConfig) GetEnforcementMode() EnforcementMode {
	if m != nil {
		return m.EnforcementMode
	}
	return EnforcementMode_ENFORCED
}

// Target defines a list of services or namespaces.
type RbacConfig_Target struct {
	// A list of services.
	Services []string `protobuf:"bytes,1,rep,name=services,proto3" json:"services,omitempty"`
	// A list of namespaces.
	Namespaces           []string `protobuf:"bytes,2,rep,name=namespaces,proto3" json:"namespaces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RbacConfig_Target) Reset()         { *m = RbacConfig_Target{} }
func (m *RbacConfig_Target) String() string { return proto.CompactTextString(m) }
func (*RbacConfig_Target) ProtoMessage()    {}
func (*RbacConfig_Target) Descriptor() ([]byte, []int) {
	return fileDescriptor_74695df94c167244, []int{0, 0}
}
func (m *RbacConfig_Target) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RbacConfig_Target.Unmarshal(m, b)
}
func (m *RbacConfig_Target) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RbacConfig_Target.Marshal(b, m, deterministic)
}
func (m *RbacConfig_Target) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RbacConfig_Target.Merge(m, src)
}
func (m *RbacConfig_Target) XXX_Size() int {
	return xxx_messageInfo_RbacConfig_Target.Size(m)
}
func (m *RbacConfig_Target) XXX_DiscardUnknown() {
	xxx_messageInfo_RbacConfig_Target.DiscardUnknown(m)
}

var xxx_messageInfo_RbacConfig_Target proto.InternalMessageInfo

func (m *RbacConfig_Target) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *RbacConfig_Target) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.rbac.v1alpha1.EnforcementMode", EnforcementMode_name, EnforcementMode_value)
	proto.RegisterEnum("istio.rbac.v1alpha1.RbacConfig_Mode", RbacConfig_Mode_name, RbacConfig_Mode_value)
	proto.RegisterType((*RbacConfig)(nil), "istio.rbac.v1alpha1.RbacConfig")
	proto.RegisterType((*RbacConfig_Target)(nil), "istio.rbac.v1alpha1.RbacConfig.Target")
}

func init() {
	proto.RegisterFile("github.com/solo-io/mesh-projects/api/external/istio/rbac/v1alpha1/rbac.proto", fileDescriptor_74695df94c167244)
}

var fileDescriptor_74695df94c167244 = []byte{
	// 515 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0xcd, 0x6e, 0xda, 0x40,
	0x18, 0x8c, 0xc1, 0xa2, 0xe4, 0x4b, 0x9a, 0x38, 0xdb, 0xb4, 0xa2, 0x1c, 0x12, 0x8a, 0xaa, 0x0a,
	0x55, 0x8a, 0x57, 0xa4, 0x97, 0x28, 0x47, 0xc0, 0xb4, 0xa8, 0x01, 0x57, 0x26, 0xfd, 0x51, 0x2f,
	0x68, 0x31, 0x1f, 0x66, 0x1b, 0xec, 0xb5, 0xbc, 0x0b, 0xca, 0x39, 0x4f, 0xd3, 0x47, 0xe9, 0x13,
	0xf4, 0x98, 0x43, 0xdf, 0x20, 0x7d, 0x82, 0xca, 0xcb, 0x5f, 0x52, 0x45, 0x25, 0x3d, 0xb1, 0xdf,
	0xcc, 0xce, 0x0c, 0xf3, 0xc9, 0x0b, 0x67, 0x01, 0x57, 0xa3, 0x49, 0xdf, 0xf6, 0x45, 0x48, 0xa5,
	0x18, 0x8b, 0x23, 0x2e, 0x68, 0x88, 0x72, 0x74, 0x14, 0x27, 0xe2, 0x1b, 0xfa, 0x4a, 0x52, 0x16,
	0x73, 0x8a, 0x97, 0x0a, 0x93, 0x88, 0x8d, 0x29, 0x97, 0x8a, 0x0b, 0x9a, 0xf4, 0x99, 0x4f, 0xa7,
	0x55, 0x36, 0x8e, 0x47, 0xac, 0xaa, 0x27, 0x3b, 0x4e, 0x84, 0x12, 0xe4, 0x89, 0xe6, 0x6d, 0x8d,
	0x2c, 0xf8, 0x62, 0xf5, 0x9e, 0x08, 0xfd, 0x7b, 0xc1, 0x95, 0x76, 0x9f, 0x56, 0x69, 0x88, 0x8a,
	0x0d, 0x98, 0x62, 0x33, 0x9f, 0x22, 0x7d, 0x80, 0x44, 0x2a, 0xa6, 0x26, 0x72, 0x2e, 0x78, 0x48,
	0xc6, 0x62, 0x9e, 0x4b, 0xf6, 0x03, 0x11, 0x08, 0x7d, 0xa4, 0xe9, 0x69, 0x86, 0x96, 0x7f, 0x9a,
	0x00, 0x5e, 0x9f, 0xf9, 0x75, 0x11, 0x0d, 0x79, 0x40, 0xde, 0x42, 0x6e, 0x96, 0x53, 0x18, 0x94,
	0x8c, 0xca, 0xd6, 0xf1, 0xbe, 0xed, 0x8b, 0x04, 0xed, 0xd4, 0xca, 0xe6, 0xc2, 0xee, 0x6a, 0xae,
	0xf6, 0xfc, 0xc7, 0xf5, 0xe1, 0xc6, 0xef, 0xeb, 0xc3, 0x3d, 0x85, 0x52, 0x0d, 0xf8, 0x70, 0x78,
	0x5a, 0xe6, 0x41, 0x24, 0x12, 0x2c, 0x7b, 0x73, 0x39, 0x39, 0x81, 0xfc, 0xa2, 0x63, 0x01, 0xb5,
	0xd5, 0xb3, 0xbb, 0x56, 0xed, 0x39, 0x5b, 0x33, 0x53, 0x33, 0x6f, 0x79, 0x9b, 0x9c, 0x80, 0x19,
	0x8a, 0x01, 0x16, 0x8c, 0x92, 0x51, 0xd9, 0x39, 0x7e, 0x69, 0xdf, 0xb3, 0x62, 0x7b, 0xf5, 0x8f,
	0xed, 0xb6, 0x18, 0xa0, 0xa7, 0x15, 0xa4, 0x01, 0x9b, 0x3c, 0xf2, 0xc7, 0x13, 0xc9, 0x45, 0x54,
	0xc8, 0xe8, 0xd0, 0x57, 0xeb, 0xe4, 0xe7, 0x2c, 0x09, 0x50, 0x79, 0x2b, 0x61, 0xea, 0x82, 0x97,
	0x0b, 0x97, 0xec, 0xff, 0xb9, 0x2c, 0x85, 0xc4, 0x05, 0x0b, 0xa3, 0xa1, 0x48, 0x7c, 0x0c, 0x31,
	0x52, 0x3d, 0xdd, 0xc8, 0xfc, 0x47, 0x23, 0x67, 0x75, 0x59, 0x37, 0xda, 0xc5, 0xbb, 0x40, 0xb1,
	0x01, 0xb9, 0x59, 0x0a, 0x29, 0x42, 0x5e, 0x62, 0x32, 0xe5, 0x3e, 0xca, 0x82, 0x51, 0xca, 0x56,
	0x36, 0xbd, 0xe5, 0x4c, 0x0e, 0x00, 0x22, 0x16, 0xa2, 0x8c, 0x59, 0xca, 0x66, 0x34, 0x7b, 0x0b,
	0x29, 0x3b, 0x60, 0xa6, 0x6e, 0xe4, 0x11, 0x64, 0xdd, 0x66, 0xd3, 0xda, 0x20, 0x39, 0xc8, 0xb8,
	0x1d, 0xcb, 0x20, 0x4f, 0x61, 0xcf, 0xed, 0xf4, 0x3e, 0xb7, 0xce, 0xdf, 0xf5, 0x5a, 0x9d, 0xfa,
	0xd9, 0xc7, 0x6e, 0xcb, 0xed, 0x58, 0x99, 0xdb, 0xb0, 0xf3, 0x65, 0x01, 0x67, 0x4f, 0x5f, 0x5c,
	0xdd, 0x98, 0xdb, 0x00, 0x69, 0x05, 0x5f, 0x6f, 0xe0, 0xea, 0xc6, 0x7c, 0x4c, 0xb6, 0x92, 0xe5,
	0x46, 0xe4, 0x6b, 0x0a, 0xbb, 0x7f, 0x75, 0x22, 0xdb, 0x90, 0x77, 0x3a, 0x4d, 0xd7, 0xab, 0x3b,
	0x0d, 0x6b, 0x83, 0xec, 0x00, 0x7c, 0x70, 0xbc, 0x76, 0xab, 0xdb, 0x6d, 0x7d, 0x72, 0x2c, 0xa3,
	0xf6, 0xfe, 0xfb, 0xaf, 0x03, 0xe3, 0xab, 0xb3, 0xf6, 0x7d, 0xc6, 0x17, 0xc1, 0xda, 0x37, 0xda,
	0xcf, 0xe9, 0xaf, 0xfb, 0xcd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x37, 0xcf, 0xa3, 0xef,
	0x03, 0x00, 0x00,
}

func (this *RbacConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RbacConfig)
	if !ok {
		that2, ok := that.(RbacConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.Inclusion.Equal(that1.Inclusion) {
		return false
	}
	if !this.Exclusion.Equal(that1.Exclusion) {
		return false
	}
	if this.EnforcementMode != that1.EnforcementMode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RbacConfig_Target) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RbacConfig_Target)
	if !ok {
		that2, ok := that.(RbacConfig_Target)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if this.Services[i] != that1.Services[i] {
			return false
		}
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if this.Namespaces[i] != that1.Namespaces[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
