// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./appmesh_client.go -destination mocks/appmesh_client.go

// source: codegen/custom/appmesh/appmesh_client.gotmpl

package appmesh

import (
	"context"

	"github.com/aws/aws-app-mesh-controller-for-k8s/pkg/aws/services"
	"github.com/aws/aws-app-mesh-controller-for-k8s/pkg/equality"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/solo-io/external-apis/pkg/api/appmesh/appmesh.aws.solo.io/v1alpha1"
	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/contrib/pkg/output"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/aws/aws-sdk-go/aws"
	appmeshsdk "github.com/aws/aws-sdk-go/service/appmesh"
	"k8s.io/apimachinery/pkg/util/sets"
)

type Client interface {
	UpsertVirtualNodes(ctx context.Context, mesh string, existingVirtualNodes sets.String, desiredVirtualNodes []*v1alpha1.VirtualNode, errHandler output.ErrorHandler)
	DeleteVirtualNodes(ctx context.Context, mesh string, staleVirtualNodes sets.String, errHandler output.ErrorHandler)
	ListVirtualNodes(ctx context.Context, meshName string) (sets.String, error)
	UpsertVirtualRouters(ctx context.Context, mesh string, existingVirtualRouters sets.String, desiredVirtualRouters []*v1alpha1.VirtualRouter, errHandler output.ErrorHandler)
	DeleteVirtualRouters(ctx context.Context, mesh string, staleVirtualRouters sets.String, errHandler output.ErrorHandler)
	ListVirtualRouters(ctx context.Context, meshName string) (sets.String, error)
	UpsertRoutes(ctx context.Context, mesh string, existingRoutes sets.String, desiredRoutes []*v1alpha1.Route, errHandler output.ErrorHandler)
	DeleteRoutes(ctx context.Context, mesh string, staleRoutes sets.String, errHandler output.ErrorHandler)
	ListRoutes(ctx context.Context, meshName string) (sets.String, error)
	UpsertVirtualServices(ctx context.Context, mesh string, existingVirtualServices sets.String, desiredVirtualServices []*v1alpha1.VirtualService, errHandler output.ErrorHandler)
	DeleteVirtualServices(ctx context.Context, mesh string, staleVirtualServices sets.String, errHandler output.ErrorHandler)
	ListVirtualServices(ctx context.Context, meshName string) (sets.String, error)
}

type client struct {
	accountId string
	appMesh   services.AppMesh
}

func NewClient(accountId string, appMesh services.AppMesh) Client {
	return &client{accountId: accountId, appMesh: appMesh}
}

func (c *client) UpsertVirtualNodes(ctx context.Context, mesh string, existingVirtualNodes sets.String, desiredVirtualNodes []*v1alpha1.VirtualNode, errHandler output.ErrorHandler) {
	for _, virtualNode := range desiredVirtualNodes {
		virtualNode := virtualNode // pike

		if virtualNode.Namespace != mesh {
			// use Namespace to represent Mesh
			continue
		}

		if err := c.upsertVirtualNode(ctx, mesh, existingVirtualNodes, virtualNode); err != nil {
			errHandler.HandleWriteError(virtualNode, err)
			continue
		}

		// ensure VirtualNode will not be garbage collected
		existingVirtualNodes.Delete(virtualNode.Name)
	}
}

func (c *client) upsertVirtualNode(ctx context.Context, mesh string, existingVirtualNodes sets.String, virtualNode *v1alpha1.VirtualNode) error {

	if existingVirtualNodes.Has(virtualNode.Name) {
		awsVirtualNode, err := c.appMesh.DescribeVirtualNodeWithContext(ctx, &appmeshsdk.DescribeVirtualNodeInput{
			MeshName:        aws.String(mesh),
			MeshOwner:       aws.String(c.accountId),
			VirtualNodeName: nil,
		})
		if err != nil {
			return err
		}

		existingVnSpec := awsVirtualNode.VirtualNode.Spec
		desiredSpec := &virtualNode.Spec

		opts := equality.CompareOptionForVirtualNodeSpec()
		if cmp.Equal(desiredSpec, existingVnSpec, opts) {
			return nil
		}

		diff := cmp.Diff(desiredSpec, existingVnSpec, opts)
		contextutils.LoggerFrom(ctx).Debugw("virtualNodeSpec changed",
			"virtualNode", sksets.Key(virtualNode),
			"existingVnSpec", existingVnSpec,
			"desiredSpec", desiredSpec,
			"diff", diff,
		)

		if _, err := c.appMesh.UpdateVirtualNodeWithContext(ctx, &appmeshsdk.UpdateVirtualNodeInput{
			MeshName:        aws.String(mesh),
			MeshOwner:       aws.String(c.accountId),
			Spec:            desiredSpec,
			VirtualNodeName: aws.String(virtualNode.Name),
		}); err != nil {
			return err
		}

	}

	contextutils.LoggerFrom(ctx).Debugw("creating virtual node",
		"virtualNode", sksets.Key(virtualNode),
		"spec", virtualNode.Spec,
	)

	if _, err := c.appMesh.CreateVirtualNode(&appmeshsdk.CreateVirtualNodeInput{
		MeshName:        aws.String(mesh),
		MeshOwner:       aws.String(c.accountId),
		Spec:            &virtualNode.Spec,
		Tags:            ConvertLabelsToTags(virtualNode.Labels),
		VirtualNodeName: aws.String(virtualNode.Name),
	}); err != nil {
		return err
	}

	return nil
}

func (c *client) DeleteVirtualNodes(ctx context.Context, mesh string, staleVirtualNodes sets.String, errHandler output.ErrorHandler) {
	for _, existingVirtualNode := range staleVirtualNodes.List() {
		if err := c.deleteVirtualNode(ctx, mesh, existingVirtualNode); err != nil {
			errHandler.HandleDeleteError(&v1alpha1.VirtualNode{ObjectMeta: metav1.ObjectMeta{
				Name:      existingVirtualNode,
				Namespace: mesh,
			}}, err)
		}
	}
}

func (c *client) deleteVirtualNode(ctx context.Context, mesh, virtualNodeName string) error {
	_, err := c.appMesh.DeleteVirtualNodeWithContext(ctx, &appmeshsdk.DeleteVirtualNodeInput{
		MeshName:        aws.String(mesh),
		MeshOwner:       aws.String(c.accountId),
		VirtualNodeName: aws.String(virtualNodeName),
	})
	return err
}

func (c *client) ListVirtualNodes(ctx context.Context, meshName string) (sets.String, error) {
	virtualNodeNames := sets.NewString()
	err := c.appMesh.ListVirtualNodesPagesWithContext(
		ctx,
		&appmeshsdk.ListVirtualNodesInput{
			MeshName: aws.String(meshName),
		},
		func(page *appmeshsdk.ListVirtualNodesOutput, isLast bool) bool {
			if page != nil {
				for _, virtualNode := range page.VirtualNodes {
					virtualNodeNames.Insert(aws.StringValue(virtualNode.VirtualNodeName))
				}
			}
			return !isLast
		},
	)
	if err != nil {
		return nil, err
	}
	return virtualNodeNames, nil
}

func (c *client) UpsertVirtualRouters(ctx context.Context, mesh string, existingVirtualRouters sets.String, desiredVirtualRouters []*v1alpha1.VirtualRouter, errHandler output.ErrorHandler) {
	for _, virtualRouter := range desiredVirtualRouters {
		virtualRouter := virtualRouter // pike

		if virtualRouter.Namespace != mesh {
			// use Namespace to represent Mesh
			continue
		}

		if err := c.upsertVirtualRouter(ctx, mesh, existingVirtualRouters, virtualRouter); err != nil {
			errHandler.HandleWriteError(virtualRouter, err)
			continue
		}

		// ensure VirtualRouter will not be garbage collected
		existingVirtualRouters.Delete(virtualRouter.Name)
	}
}

func (c *client) upsertVirtualRouter(ctx context.Context, mesh string, existingVirtualRouters sets.String, virtualRouter *v1alpha1.VirtualRouter) error {

	if existingVirtualRouters.Has(virtualRouter.Name) {
		awsVirtualRouter, err := c.appMesh.DescribeVirtualRouterWithContext(ctx, &appmeshsdk.DescribeVirtualRouterInput{
			MeshName:          aws.String(mesh),
			MeshOwner:         aws.String(c.accountId),
			VirtualRouterName: nil,
		})
		if err != nil {
			return err
		}

		existingVnSpec := awsVirtualRouter.VirtualRouter.Spec
		desiredSpec := &virtualRouter.Spec

		opts := cmpopts.EquateEmpty()
		if cmp.Equal(desiredSpec, existingVnSpec, opts) {
			return nil
		}

		diff := cmp.Diff(desiredSpec, existingVnSpec, opts)
		contextutils.LoggerFrom(ctx).Debugw("virtualRouterSpec changed",
			"virtualRouter", sksets.Key(virtualRouter),
			"existingVnSpec", existingVnSpec,
			"desiredSpec", desiredSpec,
			"diff", diff,
		)

		if _, err := c.appMesh.UpdateVirtualRouterWithContext(ctx, &appmeshsdk.UpdateVirtualRouterInput{
			MeshName:          aws.String(mesh),
			MeshOwner:         aws.String(c.accountId),
			Spec:              desiredSpec,
			VirtualRouterName: aws.String(virtualRouter.Name),
		}); err != nil {
			return err
		}

	}

	contextutils.LoggerFrom(ctx).Debugw("creating virtual node",
		"virtualRouter", sksets.Key(virtualRouter),
		"spec", virtualRouter.Spec,
	)

	if _, err := c.appMesh.CreateVirtualRouter(&appmeshsdk.CreateVirtualRouterInput{
		MeshName:          aws.String(mesh),
		MeshOwner:         aws.String(c.accountId),
		Spec:              &virtualRouter.Spec,
		Tags:              ConvertLabelsToTags(virtualRouter.Labels),
		VirtualRouterName: aws.String(virtualRouter.Name),
	}); err != nil {
		return err
	}

	return nil
}

func (c *client) DeleteVirtualRouters(ctx context.Context, mesh string, staleVirtualRouters sets.String, errHandler output.ErrorHandler) {
	for _, existingVirtualRouter := range staleVirtualRouters.List() {
		if err := c.deleteVirtualRouter(ctx, mesh, existingVirtualRouter); err != nil {
			errHandler.HandleDeleteError(&v1alpha1.VirtualRouter{ObjectMeta: metav1.ObjectMeta{
				Name:      existingVirtualRouter,
				Namespace: mesh,
			}}, err)
		}
	}
}

func (c *client) deleteVirtualRouter(ctx context.Context, mesh, virtualRouterName string) error {
	_, err := c.appMesh.DeleteVirtualRouterWithContext(ctx, &appmeshsdk.DeleteVirtualRouterInput{
		MeshName:          aws.String(mesh),
		MeshOwner:         aws.String(c.accountId),
		VirtualRouterName: aws.String(virtualRouterName),
	})
	return err
}

func (c *client) ListVirtualRouters(ctx context.Context, meshName string) (sets.String, error) {
	virtualRouterNames := sets.NewString()
	err := c.appMesh.ListVirtualRoutersPagesWithContext(
		ctx,
		&appmeshsdk.ListVirtualRoutersInput{
			MeshName: aws.String(meshName),
		},
		func(page *appmeshsdk.ListVirtualRoutersOutput, isLast bool) bool {
			if page != nil {
				for _, virtualRouter := range page.VirtualRouters {
					virtualRouterNames.Insert(aws.StringValue(virtualRouter.VirtualRouterName))
				}
			}
			return !isLast
		},
	)
	if err != nil {
		return nil, err
	}
	return virtualRouterNames, nil
}

func (c *client) UpsertRoutes(ctx context.Context, mesh string, existingRoutes sets.String, desiredRoutes []*v1alpha1.Route, errHandler output.ErrorHandler) {
	for _, route := range desiredRoutes {
		route := route // pike

		if route.Namespace != mesh {
			// use Namespace to represent Mesh
			continue
		}

		if err := c.upsertRoute(ctx, mesh, existingRoutes, route); err != nil {
			errHandler.HandleWriteError(route, err)
			continue
		}

		// ensure Route will not be garbage collected
		existingRoutes.Delete(route.Name)
	}
}

func (c *client) upsertRoute(ctx context.Context, mesh string, existingRoutes sets.String, route *v1alpha1.Route) error {

	if existingRoutes.Has(route.Name) {
		awsRoute, err := c.appMesh.DescribeRouteWithContext(ctx, &appmeshsdk.DescribeRouteInput{
			MeshName:  aws.String(mesh),
			MeshOwner: aws.String(c.accountId),
			RouteName: nil,
		})
		if err != nil {
			return err
		}

		existingVnSpec := awsRoute.Route.Spec
		desiredSpec := &route.Spec

		opts := cmpopts.EquateEmpty()
		if cmp.Equal(desiredSpec, existingVnSpec, opts) {
			return nil
		}

		diff := cmp.Diff(desiredSpec, existingVnSpec, opts)
		contextutils.LoggerFrom(ctx).Debugw("routeSpec changed",
			"route", sksets.Key(route),
			"existingVnSpec", existingVnSpec,
			"desiredSpec", desiredSpec,
			"diff", diff,
		)

		if _, err := c.appMesh.UpdateRouteWithContext(ctx, &appmeshsdk.UpdateRouteInput{
			MeshName:  aws.String(mesh),
			MeshOwner: aws.String(c.accountId),
			Spec:      desiredSpec,
			RouteName: aws.String(route.Name),
		}); err != nil {
			return err
		}

	}

	contextutils.LoggerFrom(ctx).Debugw("creating virtual node",
		"route", sksets.Key(route),
		"spec", route.Spec,
	)

	if _, err := c.appMesh.CreateRoute(&appmeshsdk.CreateRouteInput{
		MeshName:  aws.String(mesh),
		MeshOwner: aws.String(c.accountId),
		Spec:      &route.Spec,
		Tags:      ConvertLabelsToTags(route.Labels),
		RouteName: aws.String(route.Name),
	}); err != nil {
		return err
	}

	return nil
}

func (c *client) DeleteRoutes(ctx context.Context, mesh string, staleRoutes sets.String, errHandler output.ErrorHandler) {
	for _, existingRoute := range staleRoutes.List() {
		if err := c.deleteRoute(ctx, mesh, existingRoute); err != nil {
			errHandler.HandleDeleteError(&v1alpha1.Route{ObjectMeta: metav1.ObjectMeta{
				Name:      existingRoute,
				Namespace: mesh,
			}}, err)
		}
	}
}

func (c *client) deleteRoute(ctx context.Context, mesh, routeName string) error {
	_, err := c.appMesh.DeleteRouteWithContext(ctx, &appmeshsdk.DeleteRouteInput{
		MeshName:  aws.String(mesh),
		MeshOwner: aws.String(c.accountId),
		RouteName: aws.String(routeName),
	})
	return err
}

func (c *client) ListRoutes(ctx context.Context, meshName string) (sets.String, error) {
	routeNames := sets.NewString()
	err := c.appMesh.ListRoutesPagesWithContext(
		ctx,
		&appmeshsdk.ListRoutesInput{
			MeshName: aws.String(meshName),
		},
		func(page *appmeshsdk.ListRoutesOutput, isLast bool) bool {
			if page != nil {
				for _, route := range page.Routes {
					routeNames.Insert(aws.StringValue(route.RouteName))
				}
			}
			return !isLast
		},
	)
	if err != nil {
		return nil, err
	}
	return routeNames, nil
}

func (c *client) UpsertVirtualServices(ctx context.Context, mesh string, existingVirtualServices sets.String, desiredVirtualServices []*v1alpha1.VirtualService, errHandler output.ErrorHandler) {
	for _, virtualService := range desiredVirtualServices {
		virtualService := virtualService // pike

		if virtualService.Namespace != mesh {
			// use Namespace to represent Mesh
			continue
		}

		if err := c.upsertVirtualService(ctx, mesh, existingVirtualServices, virtualService); err != nil {
			errHandler.HandleWriteError(virtualService, err)
			continue
		}

		// ensure VirtualService will not be garbage collected
		existingVirtualServices.Delete(virtualService.Name)
	}
}

func (c *client) upsertVirtualService(ctx context.Context, mesh string, existingVirtualServices sets.String, virtualService *v1alpha1.VirtualService) error {

	if existingVirtualServices.Has(virtualService.Name) {
		awsVirtualService, err := c.appMesh.DescribeVirtualServiceWithContext(ctx, &appmeshsdk.DescribeVirtualServiceInput{
			MeshName:           aws.String(mesh),
			MeshOwner:          aws.String(c.accountId),
			VirtualServiceName: nil,
		})
		if err != nil {
			return err
		}

		existingVnSpec := awsVirtualService.VirtualService.Spec
		desiredSpec := &virtualService.Spec

		opts := cmpopts.EquateEmpty()
		if cmp.Equal(desiredSpec, existingVnSpec, opts) {
			return nil
		}

		diff := cmp.Diff(desiredSpec, existingVnSpec, opts)
		contextutils.LoggerFrom(ctx).Debugw("virtualServiceSpec changed",
			"virtualService", sksets.Key(virtualService),
			"existingVnSpec", existingVnSpec,
			"desiredSpec", desiredSpec,
			"diff", diff,
		)

		if _, err := c.appMesh.UpdateVirtualServiceWithContext(ctx, &appmeshsdk.UpdateVirtualServiceInput{
			MeshName:           aws.String(mesh),
			MeshOwner:          aws.String(c.accountId),
			Spec:               desiredSpec,
			VirtualServiceName: aws.String(virtualService.Name),
		}); err != nil {
			return err
		}

	}

	contextutils.LoggerFrom(ctx).Debugw("creating virtual node",
		"virtualService", sksets.Key(virtualService),
		"spec", virtualService.Spec,
	)

	if _, err := c.appMesh.CreateVirtualService(&appmeshsdk.CreateVirtualServiceInput{
		MeshName:           aws.String(mesh),
		MeshOwner:          aws.String(c.accountId),
		Spec:               &virtualService.Spec,
		Tags:               ConvertLabelsToTags(virtualService.Labels),
		VirtualServiceName: aws.String(virtualService.Name),
	}); err != nil {
		return err
	}

	return nil
}

func (c *client) DeleteVirtualServices(ctx context.Context, mesh string, staleVirtualServices sets.String, errHandler output.ErrorHandler) {
	for _, existingVirtualService := range staleVirtualServices.List() {
		if err := c.deleteVirtualService(ctx, mesh, existingVirtualService); err != nil {
			errHandler.HandleDeleteError(&v1alpha1.VirtualService{ObjectMeta: metav1.ObjectMeta{
				Name:      existingVirtualService,
				Namespace: mesh,
			}}, err)
		}
	}
}

func (c *client) deleteVirtualService(ctx context.Context, mesh, virtualServiceName string) error {
	_, err := c.appMesh.DeleteVirtualServiceWithContext(ctx, &appmeshsdk.DeleteVirtualServiceInput{
		MeshName:           aws.String(mesh),
		MeshOwner:          aws.String(c.accountId),
		VirtualServiceName: aws.String(virtualServiceName),
	})
	return err
}

func (c *client) ListVirtualServices(ctx context.Context, meshName string) (sets.String, error) {
	virtualServiceNames := sets.NewString()
	err := c.appMesh.ListVirtualServicesPagesWithContext(
		ctx,
		&appmeshsdk.ListVirtualServicesInput{
			MeshName: aws.String(meshName),
		},
		func(page *appmeshsdk.ListVirtualServicesOutput, isLast bool) bool {
			if page != nil {
				for _, virtualService := range page.VirtualServices {
					virtualServiceNames.Insert(aws.StringValue(virtualService.VirtualServiceName))
				}
			}
			return !isLast
		},
	)
	if err != nil {
		return nil, err
	}
	return virtualServiceNames, nil
}

func ConvertLabelsToTags(labels map[string]string) []*appmeshsdk.TagRef {
	var tags []*appmeshsdk.TagRef
	for k, v := range labels {
		tags = append(tags, &appmeshsdk.TagRef{
			Key:   aws.String(k),
			Value: aws.String(v),
		})
	}
	return tags
}
