// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// The Input Snapshot contains the set of all:
// * IssuedCertificates
// * CertificateRequests
// * Secrets
// * Pods
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/go-utils/contextutils"
	"k8s.io/apimachinery/pkg/api/errors"

	"github.com/rotisserie/eris"
	apiextensions_k8s_io_v1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"

	"github.com/hashicorp/go-multierror"
	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"

	certificates_smh_solo_io_v1alpha2 "github.com/solo-io/service-mesh-hub/pkg/api/certificates.smh.solo.io/v1alpha2"
	certificates_smh_solo_io_v1alpha2_sets "github.com/solo-io/service-mesh-hub/pkg/api/certificates.smh.solo.io/v1alpha2/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
)

// the snapshot of input resources consumed by translation
type Snapshot interface {

	// return the set of input IssuedCertificates
	IssuedCertificates() certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet
	// return the set of input CertificateRequests
	CertificateRequests() certificates_smh_solo_io_v1alpha2_sets.CertificateRequestSet

	// return the set of input Secrets
	Secrets() v1_sets.SecretSet
	// return the set of input Pods
	Pods() v1_sets.PodSet
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client) error

	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	issuedCertificates  certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet
	certificateRequests certificates_smh_solo_io_v1alpha2_sets.CertificateRequestSet

	secrets v1_sets.SecretSet
	pods    v1_sets.PodSet
}

func NewSnapshot(
	name string,

	issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificateRequests certificates_smh_solo_io_v1alpha2_sets.CertificateRequestSet,

	secrets v1_sets.SecretSet,
	pods v1_sets.PodSet,

) Snapshot {
	return &snapshot{
		name: name,

		issuedCertificates:  issuedCertificates,
		certificateRequests: certificateRequests,
		secrets:             secrets,
		pods:                pods,
	}
}

func (s snapshot) IssuedCertificates() certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return s.issuedCertificates
}

func (s snapshot) CertificateRequests() certificates_smh_solo_io_v1alpha2_sets.CertificateRequestSet {
	return s.certificateRequests
}

func (s snapshot) Secrets() v1_sets.SecretSet {
	return s.secrets
}

func (s snapshot) Pods() v1_sets.PodSet {
	return s.pods
}
func (s snapshot) SyncStatuses(ctx context.Context, c client.Client) error {

	for _, obj := range s.IssuedCertificates().List() {
		if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
			return err
		}
	}
	for _, obj := range s.CertificateRequests().List() {
		if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
			return err
		}
	}

	return nil
}

func (s snapshot) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client) error {

	for _, obj := range s.IssuedCertificates().List() {
		clusterClient, err := mcClient.Cluster(obj.ClusterName)
		if err != nil {
			return err
		}
		if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
			return err
		}
	}
	for _, obj := range s.CertificateRequests().List() {
		clusterClient, err := mcClient.Cluster(obj.ClusterName)
		if err != nil {
			return err
		}
		if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
			return err
		}
	}

	return nil
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["issuedCertificates"] = s.issuedCertificates.List()
	snapshotMap["certificateRequests"] = s.certificateRequests.List()
	snapshotMap["secrets"] = s.secrets.List()
	snapshotMap["pods"] = s.pods.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
// Two types of builders are available:
// a builder for snapshots of resources across multiple clusters
// a builder for snapshots of resources within a single cluster
type Builder interface {
	BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error)
}

// Options for building a snapshot
type BuildOptions struct {

	// List options for composing a snapshot from IssuedCertificates
	IssuedCertificates IssuedCertificateBuildOptions
	// List options for composing a snapshot from CertificateRequests
	CertificateRequests CertificateRequestBuildOptions

	// List options for composing a snapshot from Secrets
	Secrets SecretBuildOptions
	// List options for composing a snapshot from Pods
	Pods PodBuildOptions
}

type CrdCheckOption int

const (
	// skip checking whether a crd exists for a kind before reading it from a cluster
	CrdCheckOption_SkipCheck CrdCheckOption = iota

	// return an error if the crd does not exist for a kind before reading it from the cluster
	CrdCheckOption_ErrorIfNotPresent

	// log an error (and continue) if the crd does not exist for a kind before reading it from the cluster
	CrdCheckOption_WarnIfNotPresent

	// ignore error (and continue) if the crd does not exist for a kind before reading it from the cluster
	CrdCheckOption_IgnoreIfNotPresent
)

// Options for reading IssuedCertificates
type IssuedCertificateBuildOptions struct {

	// List options for composing a snapshot from IssuedCertificates
	ListOptions []client.ListOption

	// Verify the existence of the corresponding CRD before reading IssuedCertificates.
	// Choose a CrdCheckOption that fits your use case.
	CrdCheck CrdCheckOption
}

// Options for reading CertificateRequests
type CertificateRequestBuildOptions struct {

	// List options for composing a snapshot from CertificateRequests
	ListOptions []client.ListOption

	// Verify the existence of the corresponding CRD before reading CertificateRequests.
	// Choose a CrdCheckOption that fits your use case.
	CrdCheck CrdCheckOption
}

// Options for reading Secrets
type SecretBuildOptions struct {

	// List options for composing a snapshot from Secrets
	ListOptions []client.ListOption

	// Verify the existence of the corresponding CRD before reading Secrets.
	// Choose a CrdCheckOption that fits your use case.
	CrdCheck CrdCheckOption
}

// Options for reading Pods
type PodBuildOptions struct {

	// List options for composing a snapshot from Pods
	ListOptions []client.ListOption

	// Verify the existence of the corresponding CRD before reading Pods.
	// Choose a CrdCheckOption that fits your use case.
	CrdCheck CrdCheckOption
}

// build a snapshot from resources across multiple clusters
type multiClusterBuilder struct {
	clusters multicluster.ClusterSet
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterBuilder(
	clusters multicluster.ClusterSet,
	client multicluster.Client,
) Builder {
	return &multiClusterBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	issuedCertificates := certificates_smh_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	certificateRequests := certificates_smh_solo_io_v1alpha2_sets.NewCertificateRequestSet()

	secrets := v1_sets.NewSecretSet()
	pods := v1_sets.NewPodSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertIssuedCertificatesFromCluster(ctx, cluster, issuedCertificates, opts.IssuedCertificates); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertCertificateRequestsFromCluster(ctx, cluster, certificateRequests, opts.CertificateRequests); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSecretsFromCluster(ctx, cluster, secrets, opts.Secrets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertPodsFromCluster(ctx, cluster, pods, opts.Pods); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewSnapshot(
		name,

		issuedCertificates,
		certificateRequests,
		secrets,
		pods,
	)

	return outputSnap, errs
}

func (b *multiClusterBuilder) insertIssuedCertificatesFromCluster(ctx context.Context, cluster string, issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet, opts IssuedCertificateBuildOptions) error {
	issuedCertificateClient, err := certificates_smh_solo_io_v1alpha2.NewMulticlusterIssuedCertificateClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		cli, err := b.client.Cluster(cluster)
		if err != nil {
			return err
		}
		crdName := "issuedcertificates."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, cli, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	issuedCertificateList, err := issuedCertificateClient.ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range issuedCertificateList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		issuedCertificates.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertCertificateRequestsFromCluster(ctx context.Context, cluster string, certificateRequests certificates_smh_solo_io_v1alpha2_sets.CertificateRequestSet, opts CertificateRequestBuildOptions) error {
	certificateRequestClient, err := certificates_smh_solo_io_v1alpha2.NewMulticlusterCertificateRequestClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		cli, err := b.client.Cluster(cluster)
		if err != nil {
			return err
		}
		crdName := "certificaterequests."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, cli, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	certificateRequestList, err := certificateRequestClient.ListCertificateRequest(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificateRequestList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		certificateRequests.Insert(&item)
	}

	return nil
}

func (b *multiClusterBuilder) insertSecretsFromCluster(ctx context.Context, cluster string, secrets v1_sets.SecretSet, opts SecretBuildOptions) error {
	secretClient, err := v1.NewMulticlusterSecretClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		cli, err := b.client.Cluster(cluster)
		if err != nil {
			return err
		}
		crdName := "secrets."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, cli, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	secretList, err := secretClient.ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range secretList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		secrets.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertPodsFromCluster(ctx context.Context, cluster string, pods v1_sets.PodSet, opts PodBuildOptions) error {
	podClient, err := v1.NewMulticlusterPodClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		cli, err := b.client.Cluster(cluster)
		if err != nil {
			return err
		}
		crdName := "pods."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, cli, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	podList, err := podClient.ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		pods.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterBuilder struct {
	client client.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewSingleClusterBuilder(
	client client.Client,
) Builder {
	return &singleClusterBuilder{
		client: client,
	}
}

func (b *singleClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	issuedCertificates := certificates_smh_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	certificateRequests := certificates_smh_solo_io_v1alpha2_sets.NewCertificateRequestSet()

	secrets := v1_sets.NewSecretSet()
	pods := v1_sets.NewPodSet()

	var errs error

	if err := b.insertIssuedCertificates(ctx, issuedCertificates, opts.IssuedCertificates); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertCertificateRequests(ctx, certificateRequests, opts.CertificateRequests); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSecrets(ctx, secrets, opts.Secrets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertPods(ctx, pods, opts.Pods); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSnapshot(
		name,

		issuedCertificates,
		certificateRequests,
		secrets,
		pods,
	)

	return outputSnap, errs
}

func (b *singleClusterBuilder) insertIssuedCertificates(ctx context.Context, issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet, opts IssuedCertificateBuildOptions) error {

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		crdName := "issuedcertificates."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, b.client, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", crdName, err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	issuedCertificateList, err := certificates_smh_solo_io_v1alpha2.NewIssuedCertificateClient(b.client).ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range issuedCertificateList.Items {
		item := item // pike
		issuedCertificates.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertCertificateRequests(ctx context.Context, certificateRequests certificates_smh_solo_io_v1alpha2_sets.CertificateRequestSet, opts CertificateRequestBuildOptions) error {

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		crdName := "certificaterequests."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, b.client, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", crdName, err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	certificateRequestList, err := certificates_smh_solo_io_v1alpha2.NewCertificateRequestClient(b.client).ListCertificateRequest(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificateRequestList.Items {
		item := item // pike
		certificateRequests.Insert(&item)
	}

	return nil
}

func (b *singleClusterBuilder) insertSecrets(ctx context.Context, secrets v1_sets.SecretSet, opts SecretBuildOptions) error {

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		crdName := "secrets."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, b.client, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", crdName, err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	secretList, err := v1.NewSecretClient(b.client).ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range secretList.Items {
		item := item // pike
		secrets.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertPods(ctx context.Context, pods v1_sets.PodSet, opts PodBuildOptions) error {

	if opts.CrdCheck != CrdCheckOption_SkipCheck {
		// verify CRD is present for kind
		crdName := "pods."
		crdVersion := ""
		if checkFailed, err := verifyCrdExists(ctx, b.client, crdName, crdVersion); err != nil {
			if checkFailed {
				return eris.Wrap(err, "crd check failed")
			}
			switch opts.CrdCheck {
			case CrdCheckOption_WarnIfNotPresent:
				contextutils.LoggerFrom(ctx).Warnf("crd %v not registered (fetch err: %v)", crdName, err)
				return nil
			case CrdCheckOption_IgnoreIfNotPresent:
				return nil
			case CrdCheckOption_ErrorIfNotPresent:
				return err
			}
		}
	}

	podList, err := v1.NewPodClient(b.client).ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podList.Items {
		item := item // pike
		pods.Insert(&item)
	}

	return nil
}

func verifyCrdExists(ctx context.Context, c client.Client, crdName, crdVersion string) (bool, error) {
	var crd apiextensions_k8s_io_v1beta1.CustomResourceDefinition
	if err := c.Get(ctx, client.ObjectKey{Name: crdName}, &crd); err != nil {
		checkFailed := !errors.IsNotFound(err)
		return checkFailed, err
	}
	for _, version := range crd.Spec.Versions {
		if version.Name == crdVersion {
			return false, nil
		}
	}
	return false, eris.Errorf("version %v not found for crd %v", crdVersion, crdName)
}
