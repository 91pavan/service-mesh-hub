syntax = "proto3";
package core.zephyr.solo.io;
option go_package = "github.com/solo-io/mesh-projects/pkg/api/core.zephyr.solo.io/v1alpha1/types";

import "mesh-projects/api/core/v1alpha1/ref.proto";
import "mesh-projects/api/core/v1alpha1/health.proto";

import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

/*
Meshes represent a currently registered service mesh.
*/
message MeshSpec {
    oneof mesh_type {
        IstioMesh istio = 1;
        AwsAppMesh aws_app_mesh = 2;
        LinkerdMesh linkerd = 3;
        ConsulConnectMesh consul_connect = 4;
    }

    ResourceRef cluster = 5;
}

message MeshStatus {

}


message MeshInstallation {
    // where the control plane has been installed
    string installation_namespace = 1;

    // version of the mesh which has been installed
    // Note that the version may be "latest"
    string version = 2;
}

// Mesh object representing an installed Istio control plane
message IstioMesh {
    MeshInstallation installation = 1;
}

// Mesh object representing AWS App Mesh
message AwsAppMesh {
    MeshInstallation installation = 1;
    // The AWS region the AWS App Mesh control plane resources exist in.
    string region = 2;
}

// Mesh object representing an installed Linkerd control plane
message LinkerdMesh {
    MeshInstallation installation = 1;
}

message ConsulConnectMesh {
    MeshInstallation installation = 1;
}


message MeshGroupSpec {
    // User-provided display name for the mesh group.
    string display_name = 1;

    // The meshes contained in this group.
    repeated core.zephyr.solo.io.ResourceRef meshes = 2;

    /*
        optional: if set will use this resource ref to determine the secret from which the
        root trust bundle should be grabbed. Otherwise it will default to

        trust_bundle:
            name: cacerts
            namespace: service-mesh-hub (default write namespace)
    */
    core.zephyr.solo.io.ResourceRef trust_bundle_ref = 3;

    /*
        Shared trust is a mesh group trust model requiring a shared root certificate, as well as shared identity
        between all entities which wish to communicate within the mesh group.

        The best current example of this would be the replicated control planes example from istio:
        https://preliminary.istio.io/docs/setup/install/multicluster/gateways/
    */
    message SharedTrust {}

    /*
        Limited trust is a mesh group trust model which does not require all meshes sharing the same root certificate
        or identity model. But rather, the limited trust creates trust between meshes running on different clusters
        by connecting their ingress/egress gateways with a common cert/identity. In this model all requests
        between different have the following request path when communicating between clusters

                        cluster 1 MTLS               shared MTLS                  cluster 2 MTLS
        client/workload <-----------> egress gateway <----------> ingress gateway <--------------> server

        This approach has the downside of not maintaining identity from client to server, but allows for ad-hoc
        addition of additional clusters into a mesh group.
    */
    message LimitedTrust {}

    oneof trust_model {
        SharedTrust shared = 4;
        LimitedTrust limited = 5;
    }
}

message MeshGroupStatus {
    /*
        0:  The state of the mesh group is unknown, this most likely means that the state is being calculated.
        1:  The state of the mesh group is Good. All operations have been completed successfully, and all routing
            is enabled.
        2:  The state of the mesh group is bad. Either a mesh group operation has failed, or some portion of
            inter-mesh routing is down.

        TODO: Enumerate further information below on the following states in a description message
    */
    HealthStatus health = 1;

    enum ConfigStatus {
        // config was processed properly, and no error(s) were found
        VALID = 0;
        // config was processed properly, and error(s) were found
        INVALID = 1;
        // config could not be processed properly
        PROCESSING_ERROR = 2;
    }

    ConfigStatus config = 2;
}
