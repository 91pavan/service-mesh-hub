syntax = "proto3";
package networking.zephyr.solo.io;
option go_package = "github.com/solo-io/mesh-projects/pkg/api/networking.zephyr.solo.io/v1alpha1/types";

import "mesh-projects/api/core/v1alpha1/ref.proto";
import "mesh-projects/api/core/v1alpha1/health.proto";
import "mesh-projects/api/core/v1alpha1/status.proto";

import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

message VirtualMeshSpec {
    // User-provided display name for the virtual mesh.
    string display_name = 1;

    // The meshes contained in this virtual mesh.
    repeated core.zephyr.solo.io.ResourceRef meshes = 2;

    CertificateAuthority certificate_authority = 3;

    Federation federation = 4;

    /*
        Shared trust is a virtual mesh trust model requiring a shared root certificate, as well as shared identity
        between all entities which wish to communicate within the virtual mesh.

        The best current example of this would be the replicated control planes example from istio:
        https://preliminary.istio.io/docs/setup/install/multicluster/gateways/
    */
    message SharedTrust {}

    /*
        Limited trust is a virtual mesh trust model which does not require all meshes sharing the same root certificate
        or identity model. But rather, the limited trust creates trust between meshes running on different clusters
        by connecting their ingress/egress gateways with a common cert/identity. In this model all requests
        between different have the following request path when communicating between clusters

                        cluster 1 MTLS               shared MTLS                  cluster 2 MTLS
        client/workload <-----------> egress gateway <----------> ingress gateway <--------------> server

        This approach has the downside of not maintaining identity from client to server, but allows for ad-hoc
        addition of additional clusters into a virtual mesh.
    */
    message LimitedTrust {}

    oneof trust_model {
        SharedTrust shared = 5;
        LimitedTrust limited = 6;
    }
}

message CertificateAuthority {
    /*
        Configuration for auto-generated root certificate unique to the VirtualMesh
        Uses the X.509 format, RFC5280
    */
    message Builtin {
        // Number of days before root cert expires. Defaults to 365.
        uint32 ttl_days = 1;
        // Size in bytes of the root cert's private key. Defaults to 4096
        uint32 rsa_key_size_bytes = 2;
        // Root cert organization name. Defaults to "service-mesh-hub"
        string org_name = 3;
    }

    // Configuration for user-provided root certificate
    message Provided {
        /* Resource reference for a Secret object containing the root certificate
           certificate:
                name: cacerts
                namespace: service-mesh-hub (default write namespace)
        */
        core.zephyr.solo.io.ResourceRef certificate = 3;
    }

    // If omitted, defaults to builtin
    oneof type {
        // Use auto-generated root certificate
        Builtin builtin = 1;

        // Use user-provided root certificate
        Provided provided = 2;
    }
}

message Federation {
    enum Mode {
        // federate everything to everybody
        PERMISSIVE = 0;
    }

    Mode mode = 1;
}

message VirtualMeshStatus {
    /*
        0:  The state of the virtual mesh is unknown, this most likely means that the state is being calculated.
        1:  The state of the virtual mesh is Good. All operations have been completed successfully, and all routing
            is enabled.
        2:  The state of the virtual mesh is bad. Either a virtual mesh operation has failed, or some portion of
            inter-mesh routing is down.

        TODO: Enumerate further information below on the following states in a description message
    */
    core.zephyr.solo.io.HealthStatus health = 1;

    core.zephyr.solo.io.ComputedStatus federation_status = 2;

    core.zephyr.solo.io.ComputedStatus certificate_status = 3;

    core.zephyr.solo.io.ComputedStatus config_status = 4;
}
