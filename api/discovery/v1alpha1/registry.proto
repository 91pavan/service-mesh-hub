syntax = "proto3";
package discovery.zephyr.solo.io;
option go_package = "github.com/solo-io/mesh-projects/pkg/api/discovery.zephyr.solo.io/v1alpha1/types";

import "mesh-projects/api/core/v1alpha1/ref.proto";
import "mesh-projects/api/core/v1alpha1/status.proto";

import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

/*
    The MeshService is an abstraction for a service which we have discovered to be, or are told, is part of a
    given mesh. The Mesh object has references to the MeshServices which belong to it.
*/
message MeshServiceSpec {
    /*
       Resource ref to the underlying resource which this service is representing. It can potentially represent
       multiple different resource types, but currently supports only kubernetes services

       The type is specified on the ResourceRef.APIGroup and ResourceRef.Kind fields
    */

    KubeService kube_service = 1;

    // The mesh with which this service is associated
    core.zephyr.solo.io.ResourceRef mesh = 2;

    message Subset {
        repeated string values = 1;
    }

    map<string, Subset> subsets = 3;

    Federation federation = 4;
}

message Federation {
    string multicluster_dns_name = 1;
    repeated core.zephyr.solo.io.ResourceRef federated_to_workloads = 2;
}

message KubeService {
    core.zephyr.solo.io.ResourceRef ref = 1;
    // selectors for the set of pods targeted by the k8s Service
    map<string, string> workload_selector_labels = 2;
    // labels on the underyling k8s Service itself
    map<string, string> labels = 3;
    repeated KubeServicePort ports = 4;
}

message KubeServicePort {
    // external-facing port for this service (i.e., NOT the service's target port on the backing pods)
    uint32 port = 1;
    string name = 2;
    string protocol = 3;
}

message MeshServiceStatus {
    core.zephyr.solo.io.ComputedStatus federation_status = 1;
}

/*
    The MeshWorkload is an abstraction for a workload/client which we have discovered to be, or are told, is part of a
    given mesh. The Mesh object has references to the MeshWorkloads which belong to it.
*/
message MeshWorkloadSpec {
    /*
       Resource ref to the underlying kubernetes controller which is managing the pods associated with the workloads.
       It has the generic name kube_controller as it can represent either a deployment or a daemonset. Or potentially
       any other kubernetes object which creates injected pods.

       The type is specified on the ResourceRef.APIGroup and ResourceRef.Kind fields
    */
    core.zephyr.solo.io.ResourceRef kube_controller_ref = 1;

    KubePod kube_pod = 3;

    // The mesh with which this workload is associated
    core.zephyr.solo.io.ResourceRef mesh = 2;
}

message KubePod {

    // these are the labels directly from the pods that this controller owns
    // NB: these are NEITHER the matchLabels nor the labels on the controller itself.
    // we need these to determine which services are backed by this workload, and
    // the service backing is determined by the pod labels
    map<string, string> labels = 3;

    string service_account_name = 4;
}

message MeshWorkloadStatus {

}
