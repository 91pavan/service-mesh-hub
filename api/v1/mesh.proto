syntax = "proto3";
package supergloo.solo.io;
option go_package = "github.com/solo-io/supergloo/pkg/api/v1";

import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

// Initial API thoughts based on potential user workflows: https://github.com/solo-io/supergloo/wiki/User-Workflows
// TODO: Figure out...
// How do we want to approach the issue of changes to this config being invalidated by changes to the underlying mesh?
// For example, a user configures a route for fault detection here and then removes the route directly from the Itsio
// virtual service. Or a user sets up encryption at this level then disables it directly in Kubernetes. What to do?
// More generally, are we trying to represent a full snapshot of a mesh configuration? Or are we representing a set of
// actions a user might take, and implement the support of those actions through the underlying mesh control plane?
// If we're really modeling user actions, then potentially we should model the API more as a series of event configs
// (delay requests from A to B, set up TLS encryption) rather than mesh configs (these routes are configured on the mesh,
// TLS is enabled on the mesh).

// Notes on what Itsio and Linkerd1 support on wiki: https://github.com/solo-io/supergloo/wiki

// Any user-configurable settings for a service mesh
// This isn't meant to cover install or initial configuration of the mesh
message MeshConfig {
    MeshMetadata metadata = 1;
    Encryption encryption = 2;
    Ingress ingress = 3;
    repeated Route routes = 4;
}

// TODO: Eventually we want to plug in new meshes easier, but for now it's useful to enumerate in the config
enum MeshType {
    ISTIO = 0;
    LINKERD1 = 1;
}

message MeshMetadata {
    string name = 1;
    MeshType meshType = 2;
}

// Defines mesh-level configuration for encryption. Supports communication within a mesh and through ingress.
// Communicating between TLS and non-TLS enabled services is not supported. TODO: Is this ok?
// TODO: What do we need to support communication across mesh?
message Encryption {
    // If set to true, TLS is enabled across the entire mesh.
    bool tlsEnabled = 1;
    // If TLS is enabled, this is the name of the secret containing the certs.
    // When using Istio, this should either be "istio.default", meaning Istio is using the default Citadel cert
    // generation, or "cacert", which is a custom-uploaded Kubernetes secret containing all the cert files.
    // When using Linkerd, this is the name of a secret that will be mounted into the linkerd Kubernetes DaemonSet.
    string certSecret = 2;
}

// Defines Ingress for the service mesh. The Ingress port is 80 for HTTP with no TLS, and 443 for HTTP with TLS.
message Ingress {
    // The name of the gateway. In Istio, a Gateway is configured with this name, and a VirtualService references
    // this gateway name. In Linkerd1, an Ingress is configured with this name.
    string name = 1;
    repeated IngressHost host = 2;
}

message IngressHost {
    string host = 1;
    repeated Path paths = 2;
}

message Path {
    string pathPrefix = 1;
    Destination destination = 2;
}

message Destination {
    // In Itsio, this is the name of the Kubernetes VirtualService. In Linkerd1, this is the name of the Kubernetes Service.
    string name = 1;
    int32 port = 2;
    map<string,string> labels = 3;
}

// This is a single route, of which there may be many for a VirtualService or Service. This is a nice abstraction because
// it is easier to reason about how to apply a single route on different meshes. It's not a nice abstraction because it is
// a much more limited set of route configuration options than what itsio supports, and it may not be obvious how to apply
// all the routes for a particular name. Just a straw man to start discussing routing use cases and glooshot.
message Route {
    string name = 1;
    string host = 2;
    string pathPrefix = 3;
    string rewrite = 4;
    Destination destination = 5;
    repeated RoutePlugin routePlugins = 6;
}

message RoutePlugin {
    // ... delay, abort, weights
}

